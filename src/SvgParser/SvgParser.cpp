/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Svg.g
 *     -                            On : 2013-03-23 01:23:53
 *     -                for the parser : SvgParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SvgParser.hpp"
#include "AST/Arguments/Flag.h"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8* SvgParserTokenNames[36 + 4]
        = {
    (ANTLR_UINT8*) "<invalid>", /* String to print to indicate an invalid token */
    (ANTLR_UINT8*) "<EOR>",
    (ANTLR_UINT8*) "<DOWN>",
    (ANTLR_UINT8*) "<UP>",
    (ANTLR_UINT8*) "COMMA_WSP",
    (ANTLR_UINT8*) "DIGITS",
    (ANTLR_UINT8*) "EXPONENT",
    (ANTLR_UINT8*) "FLAG",
    (ANTLR_UINT8*) "FLOAT",
    (ANTLR_UINT8*) "HEX_DIGITS",
    (ANTLR_UINT8*) "INT",
    (ANTLR_UINT8*) "NUMBER",
    (ANTLR_UINT8*) "OCTAL_DIGITS",
    (ANTLR_UINT8*) "WS",
    (ANTLR_UINT8*) "' '",
    (ANTLR_UINT8*) "'0'",
    (ANTLR_UINT8*) "'1'",
    (ANTLR_UINT8*) "'A'",
    (ANTLR_UINT8*) "'C'",
    (ANTLR_UINT8*) "'H'",
    (ANTLR_UINT8*) "'L'",
    (ANTLR_UINT8*) "'M'",
    (ANTLR_UINT8*) "'Q'",
    (ANTLR_UINT8*) "'S'",
    (ANTLR_UINT8*) "'T'",
    (ANTLR_UINT8*) "'V'",
    (ANTLR_UINT8*) "'Z'",
    (ANTLR_UINT8*) "'\\n'",
    (ANTLR_UINT8*) "'\\r'",
    (ANTLR_UINT8*) "'\\t'",
    (ANTLR_UINT8*) "'a'",
    (ANTLR_UINT8*) "'c'",
    (ANTLR_UINT8*) "'h'",
    (ANTLR_UINT8*) "'l'",
    (ANTLR_UINT8*) "'m'",
    (ANTLR_UINT8*) "'q'",
    (ANTLR_UINT8*) "'s'",
    (ANTLR_UINT8*) "'t'",
    (ANTLR_UINT8*) "'v'",
    (ANTLR_UINT8*) "'z'"
};


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Svg.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SvgParser::getGrammarFileName()
{
    return fileName;
}

/** \brief Create a new SvgParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SvgParser::SvgParser(StreamType* instream, SvgLexer& lexer)
: ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL), m_lexer(lexer), m_isLookAheadOnly(0)

{
    // See if we can create a new parser with the standard constructor
    //
    this->init(instream);
}

/** \brief Create a new SvgParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SvgParser::SvgParser(StreamType* instream, RecognizerSharedStateType* state, SvgLexer& lexer)
: ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state), m_lexer(lexer), m_isLookAheadOnly(0)

{
    this->init(instream);
}

void SvgParser::init(StreamType* instream)
{
    /* Create a LIST for recording rule memos.
     */
    typedef RecognizerSharedStateType::RuleMemoType RuleMemoType;
    this->setRuleMemo(new RuleMemoType(15)); /* 16 bit depth is enough for 32768 rules! */

    /* Install the token table
     */
    this->get_psrstate()->set_tokenNames(SvgParserTokenNames);
}

void SvgParser::setLookAheadOnly(bool val)
{
    if (val)
    {
        m_isLookAheadOnly++;
        std::cout << "IsLookAheadOnly: set true " << m_isLookAheadOnly << std::endl;
    }
    else
    {
        m_isLookAheadOnly--;
        std::cout << "IsLookAheadOnly: set false " << m_isLookAheadOnly << std::endl;
    }

    if (m_isLookAheadOnly < 0)
    {
        throw std::runtime_error("LookAhead < 0");
    }
}

void
SvgParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SvgParser::~SvgParser()
{
    if (this->getRuleMemo() != NULL)
    {
        delete this->getRuleMemo();
        this->setRuleMemo(NULL);
    }
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8** getTokenNames()
{
    return SvgParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_coordinate423_bits[] = {ANTLR_UINT64_LIT(0x0000000000000800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_coordinate423(FOLLOW_wsp_in_coordinate423_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_NUMBER_in_coordinate425_bits[] = {ANTLR_UINT64_LIT(0x0000000038004000)};
static SvgParserImplTraits::BitsetListType FOLLOW_NUMBER_in_coordinate425(FOLLOW_NUMBER_in_coordinate425_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_coordinate427_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_coordinate427(FOLLOW_wsp_in_coordinate427_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinate_in_coordinatePair444_bits[] = {ANTLR_UINT64_LIT(0x0000000038004810)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinate_in_coordinatePair444(FOLLOW_coordinate_in_coordinatePair444_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_coordinatePair446_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_coordinatePair446(FOLLOW_COMMA_WSP_in_coordinatePair446_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinate_in_coordinatePair449_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinate_in_coordinatePair449(FOLLOW_coordinate_in_coordinatePair449_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_lineto466_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_lineto466(FOLLOW_set_in_lineto466_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_lineto476_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_lineto476(FOLLOW_wsp_in_lineto476_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_lineto478_bits[] = {ANTLR_UINT64_LIT(0x0000000038004802)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_lineto478(FOLLOW_coordinatePair_in_lineto478_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_moveto496_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_moveto496(FOLLOW_set_in_moveto496_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_moveto506_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_moveto506(FOLLOW_wsp_in_moveto506_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_moveto508_bits[] = {ANTLR_UINT64_LIT(0x0000000038004802)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_moveto508(FOLLOW_coordinatePair_in_moveto508_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_curvetoArgument548_bits[] = {ANTLR_UINT64_LIT(0x0000000038004810)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_curvetoArgument548(FOLLOW_coordinatePair_in_curvetoArgument548_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_curvetoArgument550_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_curvetoArgument550(FOLLOW_COMMA_WSP_in_curvetoArgument550_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_curvetoArgument553_bits[] = {ANTLR_UINT64_LIT(0x0000000038004810)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_curvetoArgument553(FOLLOW_coordinatePair_in_curvetoArgument553_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_curvetoArgument555_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_curvetoArgument555(FOLLOW_COMMA_WSP_in_curvetoArgument555_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_curvetoArgument558_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_curvetoArgument558(FOLLOW_coordinatePair_in_curvetoArgument558_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_curvetoArgument_in_curvetoArgumentSequence577_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_curvetoArgument_in_curvetoArgumentSequence577(FOLLOW_curvetoArgument_in_curvetoArgumentSequence577_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_curvetoArgumentSequence580_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_curvetoArgumentSequence580(FOLLOW_COMMA_WSP_in_curvetoArgumentSequence580_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_curvetoArgument_in_curvetoArgumentSequence583_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_curvetoArgument_in_curvetoArgumentSequence583(FOLLOW_curvetoArgument_in_curvetoArgumentSequence583_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_curveto602_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_curveto602(FOLLOW_set_in_curveto602_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_curveto612_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_curveto612(FOLLOW_wsp_in_curveto612_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_curvetoArgumentSequence_in_curveto614_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_curvetoArgumentSequence_in_curveto614(FOLLOW_curvetoArgumentSequence_in_curveto614_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument630_bits[] = {ANTLR_UINT64_LIT(0x0000000038004810)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument630(FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument630_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgument632_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgument632(FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgument632_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument635_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument635(FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument635_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence656_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence656(FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence656_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgumentSequence659_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgumentSequence659(FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgumentSequence659_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence662_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence662(FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence662_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_quadraticBezierCurveto688_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_quadraticBezierCurveto688(FOLLOW_set_in_quadraticBezierCurveto688_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_quadraticBezierCurveto698_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_quadraticBezierCurveto698(FOLLOW_wsp_in_quadraticBezierCurveto698_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_quadraticBezierCurvetoArgumentSequence_in_quadraticBezierCurveto700_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_quadraticBezierCurvetoArgumentSequence_in_quadraticBezierCurveto700(FOLLOW_quadraticBezierCurvetoArgumentSequence_in_quadraticBezierCurveto700_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinate_in_horizontalLinetoArgumentSequence717_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinate_in_horizontalLinetoArgumentSequence717(FOLLOW_coordinate_in_horizontalLinetoArgumentSequence717_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_horizontalLinetoArgumentSequence720_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_horizontalLinetoArgumentSequence720(FOLLOW_COMMA_WSP_in_horizontalLinetoArgumentSequence720_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinate_in_horizontalLinetoArgumentSequence723_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinate_in_horizontalLinetoArgumentSequence723(FOLLOW_coordinate_in_horizontalLinetoArgumentSequence723_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_horizontalLineto746_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_horizontalLineto746(FOLLOW_set_in_horizontalLineto746_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_horizontalLineto756_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_horizontalLineto756(FOLLOW_wsp_in_horizontalLineto756_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_horizontalLinetoArgumentSequence_in_horizontalLineto758_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_horizontalLinetoArgumentSequence_in_horizontalLineto758(FOLLOW_horizontalLinetoArgumentSequence_in_horizontalLineto758_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinate_in_verticalLinetoArgumentSequence775_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinate_in_verticalLinetoArgumentSequence775(FOLLOW_coordinate_in_verticalLinetoArgumentSequence775_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_verticalLinetoArgumentSequence778_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_verticalLinetoArgumentSequence778(FOLLOW_COMMA_WSP_in_verticalLinetoArgumentSequence778_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinate_in_verticalLinetoArgumentSequence781_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinate_in_verticalLinetoArgumentSequence781(FOLLOW_coordinate_in_verticalLinetoArgumentSequence781_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_verticalLineto804_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_verticalLineto804(FOLLOW_set_in_verticalLineto804_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_verticalLineto814_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_verticalLineto814(FOLLOW_wsp_in_verticalLineto814_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_verticalLinetoArgumentSequence_in_verticalLineto816_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_verticalLinetoArgumentSequence_in_verticalLineto816(FOLLOW_verticalLinetoArgumentSequence_in_verticalLineto816_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_smoothCurvetoArgument833_bits[] = {ANTLR_UINT64_LIT(0x0000000038004810)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_smoothCurvetoArgument833(FOLLOW_coordinatePair_in_smoothCurvetoArgument833_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_smoothCurvetoArgument835_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_smoothCurvetoArgument835(FOLLOW_COMMA_WSP_in_smoothCurvetoArgument835_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_smoothCurvetoArgument838_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_smoothCurvetoArgument838(FOLLOW_coordinatePair_in_smoothCurvetoArgument838_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence855_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence855(FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence855_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_smoothCurvetoArgumentSequence858_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_smoothCurvetoArgumentSequence858(FOLLOW_COMMA_WSP_in_smoothCurvetoArgumentSequence858_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence861_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence861(FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence861_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_smoothCurveto884_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_smoothCurveto884(FOLLOW_set_in_smoothCurveto884_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_smoothCurveto894_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_smoothCurveto894(FOLLOW_wsp_in_smoothCurveto894_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_smoothCurvetoArgumentSequence_in_smoothCurveto896_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_smoothCurvetoArgumentSequence_in_smoothCurveto896(FOLLOW_smoothCurvetoArgumentSequence_in_smoothCurveto896_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence913_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence913(FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence913_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_smoothQuadraticBezierCurvetoArgumentSequence916_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_smoothQuadraticBezierCurvetoArgumentSequence916(FOLLOW_COMMA_WSP_in_smoothQuadraticBezierCurvetoArgumentSequence916_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence919_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence919(FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence919_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_smoothQuadraticBezierCurveto938_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_smoothQuadraticBezierCurveto938(FOLLOW_set_in_smoothQuadraticBezierCurveto938_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_smoothQuadraticBezierCurveto948_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_smoothQuadraticBezierCurveto948(FOLLOW_wsp_in_smoothQuadraticBezierCurveto948_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_smoothQuadraticBezierCurvetoArgumentSequence_in_smoothQuadraticBezierCurveto950_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_smoothQuadraticBezierCurvetoArgumentSequence_in_smoothQuadraticBezierCurveto950(FOLLOW_smoothQuadraticBezierCurvetoArgumentSequence_in_smoothQuadraticBezierCurveto950_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_ellipticalArcArgument967_bits[] = {ANTLR_UINT64_LIT(0x000000003801C000)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_ellipticalArcArgument967(FOLLOW_coordinatePair_in_ellipticalArcArgument967_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_ellipticalArcArgument969_bits[] = {ANTLR_UINT64_LIT(0x0000000000018000)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_ellipticalArcArgument969(FOLLOW_wsp_in_ellipticalArcArgument969_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_flag_in_ellipticalArcArgument971_bits[] = {ANTLR_UINT64_LIT(0x000000003801C000)};
static SvgParserImplTraits::BitsetListType FOLLOW_flag_in_ellipticalArcArgument971(FOLLOW_flag_in_ellipticalArcArgument971_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_ellipticalArcArgument973_bits[] = {ANTLR_UINT64_LIT(0x0000000000018000)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_ellipticalArcArgument973(FOLLOW_wsp_in_ellipticalArcArgument973_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_flag_in_ellipticalArcArgument975_bits[] = {ANTLR_UINT64_LIT(0x000000003801C000)};
static SvgParserImplTraits::BitsetListType FOLLOW_flag_in_ellipticalArcArgument975(FOLLOW_flag_in_ellipticalArcArgument975_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_ellipticalArcArgument977_bits[] = {ANTLR_UINT64_LIT(0x0000000000018000)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_ellipticalArcArgument977(FOLLOW_wsp_in_ellipticalArcArgument977_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_flag_in_ellipticalArcArgument979_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_flag_in_ellipticalArcArgument979(FOLLOW_flag_in_ellipticalArcArgument979_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_ellipticalArcArgument981_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_ellipticalArcArgument981(FOLLOW_wsp_in_ellipticalArcArgument981_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_coordinatePair_in_ellipticalArcArgument983_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_coordinatePair_in_ellipticalArcArgument983(FOLLOW_coordinatePair_in_ellipticalArcArgument983_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1000_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1000(FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1000_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_COMMA_WSP_in_ellipticalArcArgumentSequence1003_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_COMMA_WSP_in_ellipticalArcArgumentSequence1003(FOLLOW_COMMA_WSP_in_ellipticalArcArgumentSequence1003_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1006_bits[] = {ANTLR_UINT64_LIT(0x0000000038004812)};
static SvgParserImplTraits::BitsetListType FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1006(FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1006_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_set_in_ellipticalArc1029_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_set_in_ellipticalArc1029(FOLLOW_set_in_ellipticalArc1029_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_ellipticalArc1039_bits[] = {ANTLR_UINT64_LIT(0x0000000038004800)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_ellipticalArc1039(FOLLOW_wsp_in_ellipticalArc1039_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_ellipticalArcArgumentSequence_in_ellipticalArc1041_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_ellipticalArcArgumentSequence_in_ellipticalArc1041(FOLLOW_ellipticalArcArgumentSequence_in_ellipticalArc1041_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_closepath_in_drawtoCommand1058_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_closepath_in_drawtoCommand1058(FOLLOW_closepath_in_drawtoCommand1058_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_lineto_in_drawtoCommand1066_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_lineto_in_drawtoCommand1066(FOLLOW_lineto_in_drawtoCommand1066_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_curveto_in_drawtoCommand1074_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_curveto_in_drawtoCommand1074(FOLLOW_curveto_in_drawtoCommand1074_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_quadraticBezierCurveto_in_drawtoCommand1082_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_quadraticBezierCurveto_in_drawtoCommand1082(FOLLOW_quadraticBezierCurveto_in_drawtoCommand1082_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_horizontalLineto_in_drawtoCommand1090_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_horizontalLineto_in_drawtoCommand1090(FOLLOW_horizontalLineto_in_drawtoCommand1090_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_verticalLineto_in_drawtoCommand1098_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_verticalLineto_in_drawtoCommand1098(FOLLOW_verticalLineto_in_drawtoCommand1098_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_smoothCurveto_in_drawtoCommand1106_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_smoothCurveto_in_drawtoCommand1106(FOLLOW_smoothCurveto_in_drawtoCommand1106_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_smoothQuadraticBezierCurveto_in_drawtoCommand1126_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_smoothQuadraticBezierCurveto_in_drawtoCommand1126(FOLLOW_smoothQuadraticBezierCurveto_in_drawtoCommand1126_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_ellipticalArc_in_drawtoCommand1138_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_ellipticalArc_in_drawtoCommand1138(FOLLOW_ellipticalArc_in_drawtoCommand1138_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_drawtoCommand_in_drawtoCommands1155_bits[] = {ANTLR_UINT64_LIT(0x000000FBC7DE0002)};
static SvgParserImplTraits::BitsetListType FOLLOW_drawtoCommand_in_drawtoCommands1155(FOLLOW_drawtoCommand_in_drawtoCommands1155_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_drawtoCommand_in_drawtoCommands1158_bits[] = {ANTLR_UINT64_LIT(0x000000FBC7DE0002)};
static SvgParserImplTraits::BitsetListType FOLLOW_drawtoCommand_in_drawtoCommands1158(FOLLOW_drawtoCommand_in_drawtoCommands1158_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_moveto_in_movetoDrawtoCommandGroup1177_bits[] = {ANTLR_UINT64_LIT(0x000000FBFFDE4000)};
static SvgParserImplTraits::BitsetListType FOLLOW_moveto_in_movetoDrawtoCommandGroup1177(FOLLOW_moveto_in_movetoDrawtoCommandGroup1177_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_movetoDrawtoCommandGroup1179_bits[] = {ANTLR_UINT64_LIT(0x000000FBC7DE0002)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_movetoDrawtoCommandGroup1179(FOLLOW_wsp_in_movetoDrawtoCommandGroup1179_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_drawtoCommands_in_movetoDrawtoCommandGroup1181_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_drawtoCommands_in_movetoDrawtoCommandGroup1181(FOLLOW_drawtoCommands_in_movetoDrawtoCommandGroup1181_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1199_bits[] = {ANTLR_UINT64_LIT(0x0000000438204002)};
static SvgParserImplTraits::BitsetListType FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1199(FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1199_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_movetoDrawtoCommandGroups1202_bits[] = {ANTLR_UINT64_LIT(0x0000000400200000)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_movetoDrawtoCommandGroups1202(FOLLOW_wsp_in_movetoDrawtoCommandGroups1202_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1204_bits[] = {ANTLR_UINT64_LIT(0x0000000438204002)};
static SvgParserImplTraits::BitsetListType FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1204(FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1204_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_svgPath1227_bits[] = {ANTLR_UINT64_LIT(0x0000000438204000)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_svgPath1227(FOLLOW_wsp_in_svgPath1227_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_movetoDrawtoCommandGroups_in_svgPath1229_bits[] = {ANTLR_UINT64_LIT(0x0000000038004000)};
static SvgParserImplTraits::BitsetListType FOLLOW_movetoDrawtoCommandGroups_in_svgPath1229(FOLLOW_movetoDrawtoCommandGroups_in_svgPath1229_bits, 1);
/** Bitset defining follow set for error recovery in rule state: SvgParser  */
static ANTLR_BITWORD FOLLOW_wsp_in_svgPath1232_bits[] = {ANTLR_UINT64_LIT(0x0000000000000002)};
static SvgParserImplTraits::BitsetListType FOLLOW_wsp_in_svgPath1232(FOLLOW_wsp_in_svgPath1232_bits, 1);


/* ==============================================
 * Parsing rules
 */

/**
 * $ANTLR start wsp
 * Svg.g:59:1: wsp : ( ' ' | '\\n' | '\\r' | '\\t' )? ;
 */
void SvgParser::wsp()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER wsp_StartIndex;
    wsp_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(1)))
    {
        return;
    }

    {
        // Svg.g:59:4: ( ( ' ' | '\\n' | '\\r' | '\\t' )? )
        // Svg.g:60:5: ( ' ' | '\\n' | '\\r' | '\\t' )?
        {
            // Svg.g:60:5: ( ' ' | '\\n' | '\\r' | '\\t' )?
            {
                int alt1 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        alt1 = 1;
                    }
                        break;
                }

                switch (alt1)
                {
                    case 1: // Svg.g:
                    {
                        if (this->LA(1) == 14 || ((this->LA(1) >= 27) && (this->LA(1) <= 29)))
                        {
                            this->consume();
                            this->set_perror_recovery(false);
                            this->set_failedflag(false);
                        }
                        else
                        {
                            if (this->get_backtracking() > 0)
                            {
                                this->set_failedflag(true);
                                return;
                            }

                            new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                            this->get_exception()->set_expectingSet(NULL);
                            goto rulewspEx;
                        }
                    }
                        break;
                }
            }
        }
    }

    goto rulewspEx; /* Prevent compiler warnings */
rulewspEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(1, wsp_StartIndex);
    }

    return;
}
/* $ANTLR end wsp */

/**
 * $ANTLR start flag
 * Svg.g:62:1: flag : ( '0' | '1' ) ;
 */
Flag* SvgParser::flag()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER flag_StartIndex;
    flag_StartIndex = this->index();

    std::cout << "Flag" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(2)))
    {
        return NULL;
    }

    Flag* flag = new Flag();

    {
        // Svg.g:62:5: ( ( '0' | '1' ) )
        // Svg.g:
        {
            if (((this->LA(1) >= 15) && (this->LA(1) <= 16)))
            {
                if (this->LA(1) == 15)
                {
                    flag->SetValue(false);
                }
                else
                {
                    flag->SetValue(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(flag);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);
                goto ruleflagEx;
            }
        }
    }

    goto ruleflagEx; /* Prevent compiler warnings */
ruleflagEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(2, flag_StartIndex);
    }

    return flag;
}
/* $ANTLR end flag */

/**
 * $ANTLR start coordinate
 * Svg.g:71:1: coordinate : wsp NUMBER wsp ;
 */
Coordinate* SvgParser::coordinate()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER coordinate_StartIndex;
    coordinate_StartIndex = this->index();

    std::cout << "coordinate" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(3)))
    {
        return NULL;
    }

    Coordinate* coordinate = new Coordinate();

    {
        // Svg.g:71:11: ( wsp NUMBER wsp )
        // Svg.g:72:5: wsp NUMBER wsp
        {
            this->followPush(FOLLOW_wsp_in_coordinate423);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulecoordinateEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(coordinate);
                return NULL;
            }

            this->matchToken(NUMBER, &FOLLOW_NUMBER_in_coordinate425);
            if (this->hasException())
            {
                goto rulecoordinateEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(coordinate);
                return NULL;
            }

            this->followPush(FOLLOW_wsp_in_coordinate427);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulecoordinateEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(coordinate);
                return NULL;
            }
        }
    }

    goto rulecoordinateEx; /* Prevent compiler warnings */
rulecoordinateEx:
    ;

    coordinate->setValue(std::atof(m_lexer.getIdentifierString().c_str()));

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(3, coordinate_StartIndex);
    }

    return coordinate;
}
/* $ANTLR end coordinate */

/**
 * $ANTLR start coordinatePair
 * Svg.g:75:1: coordinatePair : coordinate ( COMMA_WSP )? coordinate ;
 */
CoordinatePair* SvgParser::coordinatePair()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER coordinatePair_StartIndex;
    coordinatePair_StartIndex = this->index();

    std::cout << "coordinatePair" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(4)))
    {
        return NULL;
    }

    CoordinatePair* coordinatePair = new CoordinatePair();

    {
        // Svg.g:75:15: ( coordinate ( COMMA_WSP )? coordinate )
        // Svg.g:76:5: coordinate ( COMMA_WSP )? coordinate
        {
            this->followPush(FOLLOW_coordinate_in_coordinatePair444);
            coordinatePair->SetNumberX(coordinate());

            this->followPop();
            if (this->hasException())
            {
                goto rulecoordinatePairEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(coordinatePair);
                return NULL;
            }

            // Svg.g:76:16: ( COMMA_WSP )?
            {
                int alt2 = 2;
                switch (this->LA(1))
                {
                    case COMMA_WSP:
                    {
                        alt2 = 1;
                    }
                        break;
                }

                switch (alt2)
                {
                    case 1: // Svg.g:76:16: COMMA_WSP
                    {
                        this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_coordinatePair446);
                        if (this->hasException())
                        {
                            goto rulecoordinatePairEx;
                        }
                        if (this->hasFailed())
                        {
                            SAFE_DELETE(coordinatePair);
                            return NULL;
                        }
                    }
                        break;
                }
            }

            this->followPush(FOLLOW_coordinate_in_coordinatePair449);
            coordinatePair->SetNumberY(coordinate());

            this->followPop();
            if (this->hasException())
            {
                goto rulecoordinatePairEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(coordinatePair);
                return NULL;
            }
        }
    }

    goto rulecoordinatePairEx; /* Prevent compiler warnings */
rulecoordinatePairEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(4, coordinatePair_StartIndex);
    }

    return coordinatePair;
}
/* $ANTLR end coordinatePair */

/**
 * $ANTLR start lineto
 * Svg.g:79:1: lineto : ( 'L' | 'l' ) wsp ( coordinatePair )+ ;
 */
Command* SvgParser::lineto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER lineto_StartIndex;
    lineto_StartIndex = this->index();

    std::cout << "lineTo" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(5)))
    {
        return NULL;
    }

    LineToCommand* lineTo = new LineToCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:80:5: ( ( 'L' | 'l' ) wsp ( coordinatePair )+ )
        // Svg.g:80:7: ( 'L' | 'l' ) wsp ( coordinatePair )+
        {
            if (this->LA(1) == 20 || this->LA(1) == 33)
            {
                if (this->LA(1) == 20)
                {
                    lineTo->setRelative(false);
                }
                else
                {
                    lineTo->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(lineTo);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto rulelinetoEx;
            }


            this->followPush(FOLLOW_wsp_in_lineto476);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulelinetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(lineTo);
                return NULL;
            }

            // Svg.g:80:25: ( coordinatePair )+
            {
                int cnt3 = 0;

                for (;;)
                {
                    int alt3 = 2;
                    switch (this->LA(1))
                    {
                        case 14:
                        case 27:
                        case 28:
                        case 29:
                        {
                            switch (this->LA(2))
                            {
                                case NUMBER:
                                {
                                    alt3 = 1;
                                }
                                    break;
                            }
                        }
                            break;
                        case NUMBER:
                        {
                            alt3 = 1;
                        }
                            break;
                    }

                    switch (alt3)
                    {
                        case 1: // Svg.g:80:25: coordinatePair
                        {
                            this->followPush(FOLLOW_coordinatePair_in_lineto478);
                            args.push_back(coordinatePair());

                            this->followPop();
                            if (this->hasException())
                            {
                                goto rulelinetoEx;
                            }
                            if (this->hasFailed())
                            {
                                return NULL;
                            }
                        }
                            break;

                        default:

                            if (cnt3 >= 1)
                            {
                                goto loop3;
                            }
                            if (this->get_backtracking() > 0)
                            {
                                this->set_failedflag(true);
                                return NULL;
                            }

                            new ANTLR_Exception< SvgParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");

                            goto rulelinetoEx;
                    }
                    cnt3++;
                }
loop3:
                ; /* Jump to here if this rule does not match */
            }
        }
    }
    goto rulelinetoEx; /* Prevent compiler warnings */
rulelinetoEx:
    ;

    lineTo->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(5, lineto_StartIndex);
    }

    return lineTo;
}
/* $ANTLR end lineto */

/**
 * $ANTLR start moveto
 * Svg.g:83:1: moveto : ( 'M' | 'm' ) wsp ( coordinatePair )+ ;
 */
Command* SvgParser::moveto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER moveto_StartIndex;
    moveto_StartIndex = this->index();

    std::cout << "moveTo" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(6)))
    {
        return NULL;
    }

    MoveToCommand* moveTo = new MoveToCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:83:7: ( ( 'M' | 'm' ) wsp ( coordinatePair )+ )
        // Svg.g:84:5: ( 'M' | 'm' ) wsp ( coordinatePair )+
        {
            if (this->LA(1) == 21 || this->LA(1) == 34)
            {
                if (this->LA(1) == 21)
                {
                    moveTo->setRelative(false);
                }
                else
                {
                    moveTo->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(moveTo);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto rulemovetoEx;
            }


            this->followPush(FOLLOW_wsp_in_moveto506);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulemovetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(moveTo);
                return NULL;
            }

            // Svg.g:84:23: ( coordinatePair )+
            {
                int cnt4 = 0;
                for (;;)
                {
                    int alt4 = 2;
                    switch (this->LA(1))
                    {
                        case 14:
                        case 27:
                        case 28:
                        case 29:
                        {
                            switch (this->LA(2))
                            {
                                case NUMBER:
                                {
                                    alt4 = 1;
                                }
                                    break;
                            }
                        }
                            break;
                        case NUMBER:
                        {
                            alt4 = 1;
                        }
                            break;
                    }

                    switch (alt4)
                    {
                        case 1: // Svg.g:84:23: coordinatePair
                        {
                            this->followPush(FOLLOW_coordinatePair_in_moveto508);
                            if (cnt4 == 0)
                            {
                                CoordinatePair* pair = coordinatePair();
                                moveTo->setStartPoint(pair);
                                args.push_back(pair);
                            }
                            else
                            {
                                args.push_back(coordinatePair());
                            }

                            this->followPop();
                            if (this->hasException())
                            {
                                goto rulemovetoEx;
                            }
                            if (this->hasFailed())
                            {
                                SAFE_DELETE(moveTo);
                                return NULL;
                            }
                        }
                            break;

                        default:

                            if (cnt4 >= 1)
                            {
                                goto loop4;
                            }
                            if (this->get_backtracking() > 0)
                            {
                                this->set_failedflag(true);
                                SAFE_DELETE(moveTo);
                                return NULL;
                            }

                            new ANTLR_Exception< SvgParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");
                            goto rulemovetoEx;
                    }
                    cnt4++;
                }
loop4:
                ; /* Jump to here if this rule does not match */
            }
        }
    }

    goto rulemovetoEx; /* Prevent compiler warnings */
rulemovetoEx:
    ;

    moveTo->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(6, moveto_StartIndex);
    }

    return moveTo;
}
/* $ANTLR end moveto */

/**
 * $ANTLR start closepath
 * Svg.g:87:1: closepath : ( 'Z' | 'z' ) ;
 */
Command* SvgParser::closepath()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER closepath_StartIndex;
    closepath_StartIndex = this->index();

    std::cout << "closePath" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(7)))
    {
        return NULL;
    }

    CloseCommand* close = new CloseCommand();

    {
        // Svg.g:87:10: ( ( 'Z' | 'z' ) )
        // Svg.g:
        {
            if (this->LA(1) == 26 || this->LA(1) == 39)
            {
                if (this->LA(1) == 26)
                {
                    close->setRelative(false);
                }
                else
                {
                    close->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(close);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto ruleclosepathEx;
            }
        }
    }

    goto ruleclosepathEx; /* Prevent compiler warnings */
ruleclosepathEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(7, closepath_StartIndex);
    }

    return close;
}
/* $ANTLR end closepath */

/**
 * $ANTLR start curvetoArgument
 * Svg.g:91:1: curvetoArgument : coordinatePair ( COMMA_WSP )? coordinatePair ( COMMA_WSP )? coordinatePair ;
 */
void SvgParser::curvetoArgument(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER curvetoArgument_StartIndex;
    curvetoArgument_StartIndex = this->index();

    std::cout << "curveToArgumentSequence" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(8)))
    {
        return;
    }

    {
        // Svg.g:91:16: ( coordinatePair ( COMMA_WSP )? coordinatePair ( COMMA_WSP )? coordinatePair )
        // Svg.g:92:5: coordinatePair ( COMMA_WSP )? coordinatePair ( COMMA_WSP )? coordinatePair
        {
            this->followPush(FOLLOW_coordinatePair_in_curvetoArgument548);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulecurvetoArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:92:20: ( COMMA_WSP )?
            {
                int alt5 = 2;
                switch (this->LA(1))
                {
                    case COMMA_WSP:
                    {
                        alt5 = 1;
                    }
                        break;
                }

                switch (alt5)
                {
                    case 1: // Svg.g:92:20: COMMA_WSP
                    {
                        this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_curvetoArgument550);
                        if (this->hasException())
                        {
                            goto rulecurvetoArgumentEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;
                }
            }

            this->followPush(FOLLOW_coordinatePair_in_curvetoArgument553);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulecurvetoArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:92:46: ( COMMA_WSP )?
            {
                int alt6 = 2;
                switch (this->LA(1))
                {
                    case COMMA_WSP:
                    {
                        alt6 = 1;
                    }
                        break;
                }

                switch (alt6)
                {
                    case 1: // Svg.g:92:46: COMMA_WSP
                    {
                        this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_curvetoArgument555);
                        if (this->hasException())
                        {
                            goto rulecurvetoArgumentEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;
                }
            }

            this->followPush(FOLLOW_coordinatePair_in_curvetoArgument558);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulecurvetoArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }
        }
    }

    goto rulecurvetoArgumentEx; /* Prevent compiler warnings */
rulecurvetoArgumentEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(8, curvetoArgument_StartIndex);
    }

    return;
}
/* $ANTLR end curvetoArgument */

/**
 * $ANTLR start curvetoArgumentSequence
 * Svg.g:95:1: curvetoArgumentSequence : curvetoArgument ( ( COMMA_WSP )? curvetoArgument )* ;
 */
void SvgParser::curvetoArgumentSequence(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER curvetoArgumentSequence_StartIndex;
    curvetoArgumentSequence_StartIndex = this->index();

    std::cout << "curveToArgumentSequence" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(9)))
    {
        return;
    }

    {
        // Svg.g:95:24: ( curvetoArgument ( ( COMMA_WSP )? curvetoArgument )* )
        // Svg.g:96:5: curvetoArgument ( ( COMMA_WSP )? curvetoArgument )*
        {
            this->followPush(FOLLOW_curvetoArgument_in_curvetoArgumentSequence577);
            curvetoArgument(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulecurvetoArgumentSequenceEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:96:21: ( ( COMMA_WSP )? curvetoArgument )*
            for (;;)
            {
                int alt8 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case NUMBER:
                            {
                                alt8 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case COMMA_WSP:
                    case NUMBER:
                    {
                        alt8 = 1;
                    }
                        break;
                }

                switch (alt8)
                {
                    case 1: // Svg.g:96:22: ( COMMA_WSP )? curvetoArgument
                    { // Svg.g:96:22: ( COMMA_WSP )?
                        {
                            int alt7 = 2;
                            switch (this->LA(1))
                            {
                                case COMMA_WSP:
                                {
                                    alt7 = 1;
                                }
                                    break;
                            }

                            switch (alt7)
                            {
                                case 1: // Svg.g:96:22: COMMA_WSP
                                {
                                    this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_curvetoArgumentSequence580);
                                    if (this->hasException())
                                    {
                                        goto rulecurvetoArgumentSequenceEx;
                                    }
                                    if (this->hasFailed())
                                    {
                                        return;
                                    }
                                }
                                    break;
                            }
                        }

                        this->followPush(FOLLOW_curvetoArgument_in_curvetoArgumentSequence583);
                        curvetoArgument(args);

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulecurvetoArgumentSequenceEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop8; /* break out of the loop */
                        break;
                }
            }
loop8:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto rulecurvetoArgumentSequenceEx; /* Prevent compiler warnings */
rulecurvetoArgumentSequenceEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(9, curvetoArgumentSequence_StartIndex);
    }

    return;
}
/* $ANTLR end curvetoArgumentSequence */

/**
 * $ANTLR start curveto
 * Svg.g:99:1: curveto : ( 'C' | 'c' ) wsp curvetoArgumentSequence ;
 */
Command* SvgParser::curveto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER curveto_StartIndex;
    curveto_StartIndex = this->index();

    std::cout << "curveTo" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(10)))
    {
        return NULL;
    }

    CurveToCommand* curveCommand = new CurveToCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:99:8: ( ( 'C' | 'c' ) wsp curvetoArgumentSequence )
        // Svg.g:100:5: ( 'C' | 'c' ) wsp curvetoArgumentSequence
        {
            if (this->LA(1) == 18 || this->LA(1) == 31)
            {
                if (this->LA(1) == 18)
                {
                    curveCommand->setRelative(false);
                }
                else
                {
                    curveCommand->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(curveCommand);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto rulecurvetoEx;
            }

            this->followPush(FOLLOW_wsp_in_curveto612);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulecurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(curveCommand);
                return NULL;
            }

            this->followPush(FOLLOW_curvetoArgumentSequence_in_curveto614);
            curvetoArgumentSequence(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulecurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(curveCommand);
                return NULL;
            }
        }
    }

    goto rulecurvetoEx; /* Prevent compiler warnings */
rulecurvetoEx:
    ;

    curveCommand->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(10, curveto_StartIndex);
    }

    return curveCommand;
}
/* $ANTLR end curveto */

/**
 * $ANTLR start quadraticBezierCurvetoArgument
 * Svg.g:103:1: quadraticBezierCurvetoArgument : coordinatePair ( COMMA_WSP )? coordinatePair ;
 */
void SvgParser::quadraticBezierCurvetoArgument(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER quadraticBezierCurvetoArgument_StartIndex;
    quadraticBezierCurvetoArgument_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(11)))
    {
        return;
    }

    {
        // Svg.g:103:31: ( coordinatePair ( COMMA_WSP )? coordinatePair )
        // Svg.g:104:5: coordinatePair ( COMMA_WSP )? coordinatePair
        {
            this->followPush(FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument630);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulequadraticBezierCurvetoArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:104:20: ( COMMA_WSP )?
            {
                int alt9 = 2;
                switch (this->LA(1))
                {
                    case COMMA_WSP:
                    {
                        alt9 = 1;
                    }
                        break;
                }

                switch (alt9)
                {
                    case 1:
                        // Svg.g:104:20: COMMA_WSP
                    {
                        this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgument632);
                        if (this->hasException())
                        {
                            goto rulequadraticBezierCurvetoArgumentEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;
                }
            }

            this->followPush(FOLLOW_coordinatePair_in_quadraticBezierCurvetoArgument635);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulequadraticBezierCurvetoArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }
        }
    }

    goto rulequadraticBezierCurvetoArgumentEx; /* Prevent compiler warnings */
rulequadraticBezierCurvetoArgumentEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(11, quadraticBezierCurvetoArgument_StartIndex);
    }

    return;
}
/* $ANTLR end quadraticBezierCurvetoArgument */

/**
 * $ANTLR start quadraticBezierCurvetoArgumentSequence
 * Svg.g:107:1: quadraticBezierCurvetoArgumentSequence : quadraticBezierCurvetoArgument ( ( COMMA_WSP )? quadraticBezierCurvetoArgument )* ;
 */
void SvgParser::quadraticBezierCurvetoArgumentSequence(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER quadraticBezierCurvetoArgumentSequence_StartIndex;
    quadraticBezierCurvetoArgumentSequence_StartIndex = this->index();

    std::cout << "quadraticBezierCurvetoArgumentSequence" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(12)))
    {
        return;
    }

    {
        // Svg.g:107:39: ( quadraticBezierCurvetoArgument ( ( COMMA_WSP )? quadraticBezierCurvetoArgument )* )
        // Svg.g:108:5: quadraticBezierCurvetoArgument ( ( COMMA_WSP )? quadraticBezierCurvetoArgument )*
        {
            this->followPush(FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence656);
            quadraticBezierCurvetoArgument(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulequadraticBezierCurvetoArgumentSequenceEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:108:36: ( ( COMMA_WSP )? quadraticBezierCurvetoArgument )*
            for (;;)
            {
                int alt11 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case NUMBER:
                            {
                                alt11 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case COMMA_WSP:
                    case NUMBER:
                    {
                        alt11 = 1;
                    }
                        break;
                }

                switch (alt11)
                {
                    case 1: // Svg.g:108:37: ( COMMA_WSP )? quadraticBezierCurvetoArgument
                    { // Svg.g:108:37: ( COMMA_WSP )?
                        {
                            int alt10 = 2;
                            switch (this->LA(1))
                            {
                                case COMMA_WSP:
                                {
                                    alt10 = 1;
                                }
                                    break;
                            }

                            switch (alt10)
                            {
                                case 1: // Svg.g:108:37: COMMA_WSP
                                {
                                    this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_quadraticBezierCurvetoArgumentSequence659);
                                    if (this->hasException())
                                    {
                                        goto rulequadraticBezierCurvetoArgumentSequenceEx;
                                    }
                                    if (this->hasFailed())
                                    {
                                        return;
                                    }
                                }
                                    break;
                            }
                        }

                        this->followPush(FOLLOW_quadraticBezierCurvetoArgument_in_quadraticBezierCurvetoArgumentSequence662);
                        quadraticBezierCurvetoArgument(args);

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulequadraticBezierCurvetoArgumentSequenceEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop11; /* break out of the loop */
                        break;
                }
            }
loop11:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto rulequadraticBezierCurvetoArgumentSequenceEx; /* Prevent compiler warnings */
rulequadraticBezierCurvetoArgumentSequenceEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(12, quadraticBezierCurvetoArgumentSequence_StartIndex);
    }

    return;
}
/* $ANTLR end quadraticBezierCurvetoArgumentSequence */

/**
 * $ANTLR start quadraticBezierCurveto
 * Svg.g:111:1: quadraticBezierCurveto : ( 'Q' | 'q' ) wsp quadraticBezierCurvetoArgumentSequence ;
 */
Command* SvgParser::quadraticBezierCurveto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER quadraticBezierCurveto_StartIndex;
    quadraticBezierCurveto_StartIndex = this->index();

    std::cout << "quadraticBezierCurveto" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(13)))
    {
        return NULL;
    }

    QuadraticBezierCurveToCommand* bezier = new QuadraticBezierCurveToCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:111:23: ( ( 'Q' | 'q' ) wsp quadraticBezierCurvetoArgumentSequence )
        // Svg.g:112:5: ( 'Q' | 'q' ) wsp quadraticBezierCurvetoArgumentSequence
        {
            if (this->LA(1) == 22 || this->LA(1) == 35)
            {
                if (this->LA(1) == 22)
                {
                    bezier->setRelative(false);
                }
                else
                {
                    bezier->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(bezier);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto rulequadraticBezierCurvetoEx;
            }

            this->followPush(FOLLOW_wsp_in_quadraticBezierCurveto698);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulequadraticBezierCurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(bezier);
                return NULL;
            }

            this->followPush(FOLLOW_quadraticBezierCurvetoArgumentSequence_in_quadraticBezierCurveto700);
            quadraticBezierCurvetoArgumentSequence(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulequadraticBezierCurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(bezier);
                return NULL;
            }
        }
    }

    goto rulequadraticBezierCurvetoEx; /* Prevent compiler warnings */
rulequadraticBezierCurvetoEx:
    ;

    bezier->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(13, quadraticBezierCurveto_StartIndex);
    }

    return bezier;
}
/* $ANTLR end quadraticBezierCurveto */

/**
 * $ANTLR start horizontalLinetoArgumentSequence
 * Svg.g:115:1: horizontalLinetoArgumentSequence : coordinate ( ( COMMA_WSP )? coordinate )* ;
 */
void SvgParser::horizontalLinetoArgumentSequence(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER horizontalLinetoArgumentSequence_StartIndex;
    horizontalLinetoArgumentSequence_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(14)))
    {
        return;
    }

    std::cout << "horizontalLinetoArgumentSequence" << std::endl;

    {
        // Svg.g:115:33: ( coordinate ( ( COMMA_WSP )? coordinate )* )
        // Svg.g:116:5: coordinate ( ( COMMA_WSP )? coordinate )*
        {
            this->followPush(FOLLOW_coordinate_in_horizontalLinetoArgumentSequence717);
            args.push_back(coordinate());

            this->followPop();
            if (this->hasException())
            {
                goto rulehorizontalLinetoArgumentSequenceEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:116:16: ( ( COMMA_WSP )? coordinate )*
            for (;;)
            {
                int alt13 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case NUMBER:
                            {
                                alt13 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case COMMA_WSP:
                    case NUMBER:
                    {
                        alt13 = 1;
                    }
                        break;
                }

                switch (alt13)
                {
                    case 1: // Svg.g:116:17: ( COMMA_WSP )? coordinate
                    { // Svg.g:116:17: ( COMMA_WSP )?
                        {
                            int alt12 = 2;
                            switch (this->LA(1))
                            {
                                case COMMA_WSP:
                                {
                                    alt12 = 1;
                                }
                                    break;
                            }

                            switch (alt12)
                            {
                                case 1: // Svg.g:116:17: COMMA_WSP
                                {
                                    this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_horizontalLinetoArgumentSequence720);
                                    if (this->hasException())
                                    {
                                        goto rulehorizontalLinetoArgumentSequenceEx;
                                    }
                                    if (this->hasFailed())
                                    {
                                        return;
                                    }
                                }
                                    break;
                            }
                        }

                        this->followPush(FOLLOW_coordinate_in_horizontalLinetoArgumentSequence723);
                        args.push_back(coordinate());

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulehorizontalLinetoArgumentSequenceEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop13; /* break out of the loop */
                        break;
                }
            }
loop13:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto rulehorizontalLinetoArgumentSequenceEx; /* Prevent compiler warnings */
rulehorizontalLinetoArgumentSequenceEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(14, horizontalLinetoArgumentSequence_StartIndex);
    }

    return;
}
/* $ANTLR end horizontalLinetoArgumentSequence */

/**
 * $ANTLR start horizontalLineto
 * Svg.g:119:1: horizontalLineto : ( 'H' | 'h' ) wsp horizontalLinetoArgumentSequence ;
 */
Command* SvgParser::horizontalLineto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER horizontalLineto_StartIndex;
    horizontalLineto_StartIndex = this->index();

    std::cout << "horizontalLineTo" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(15)))
    {
        return NULL;
    }

    HorizontalLineToCommand* horizontal = new HorizontalLineToCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:119:17: ( ( 'H' | 'h' ) wsp horizontalLinetoArgumentSequence )
        // Svg.g:120:5: ( 'H' | 'h' ) wsp horizontalLinetoArgumentSequence
        {
            if (this->LA(1) == 19 || this->LA(1) == 32)
            {
                if (this->LA(1) == 19)
                {
                    horizontal->setRelative(false);
                }
                else
                {
                    horizontal->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(horizontal);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto rulehorizontalLinetoEx;
            }

            this->followPush(FOLLOW_wsp_in_horizontalLineto756);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulehorizontalLinetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(horizontal);
                return NULL;
            }

            this->followPush(FOLLOW_horizontalLinetoArgumentSequence_in_horizontalLineto758);
            horizontalLinetoArgumentSequence(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulehorizontalLinetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(horizontal);
                return NULL;
            }
        }
    }

    goto rulehorizontalLinetoEx; /* Prevent compiler warnings */
rulehorizontalLinetoEx:
    ;

    horizontal->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(15, horizontalLineto_StartIndex);
    }

    return horizontal;
}
/* $ANTLR end horizontalLineto */

/**
 * $ANTLR start verticalLinetoArgumentSequence
 * Svg.g:123:1: verticalLinetoArgumentSequence : coordinate ( ( COMMA_WSP )? coordinate )* ;
 */
void SvgParser::verticalLinetoArgumentSequence(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER verticalLinetoArgumentSequence_StartIndex;
    verticalLinetoArgumentSequence_StartIndex = this->index();

    std::cout << "verticalLinetoArgumentSequence" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(16)))
    {
        return;
    }

    {
        // Svg.g:123:31: ( coordinate ( ( COMMA_WSP )? coordinate )* )
        // Svg.g:124:5: coordinate ( ( COMMA_WSP )? coordinate )*
        {
            this->followPush(FOLLOW_coordinate_in_verticalLinetoArgumentSequence775);
            args.push_back(coordinate());

            this->followPop();
            if (this->hasException())
            {
                goto ruleverticalLinetoArgumentSequenceEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:124:16: ( ( COMMA_WSP )? coordinate )*
            for (;;)
            {
                int alt15 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case NUMBER:
                            {
                                alt15 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case COMMA_WSP:
                    case NUMBER:
                    {
                        alt15 = 1;
                    }
                        break;
                }

                switch (alt15)
                {
                    case 1: // Svg.g:124:17: ( COMMA_WSP )? coordinate
                    { // Svg.g:124:17: ( COMMA_WSP )?
                        {
                            int alt14 = 2;
                            switch (this->LA(1))
                            {
                                case COMMA_WSP:
                                {
                                    alt14 = 1;
                                }
                                    break;
                            }

                            switch (alt14)
                            {
                                case 1: // Svg.g:124:17: COMMA_WSP
                                {
                                    this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_verticalLinetoArgumentSequence778);
                                    if (this->hasException())
                                    {
                                        goto ruleverticalLinetoArgumentSequenceEx;
                                    }
                                    if (this->hasFailed())
                                    {
                                        return;
                                    }
                                }
                                    break;
                            }
                        }

                        this->followPush(FOLLOW_coordinate_in_verticalLinetoArgumentSequence781);
                        args.push_back(coordinate());

                        this->followPop();
                        if (this->hasException())
                        {
                            goto ruleverticalLinetoArgumentSequenceEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop15; /* break out of the loop */
                        break;
                }
            }
loop15:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto ruleverticalLinetoArgumentSequenceEx; /* Prevent compiler warnings */
ruleverticalLinetoArgumentSequenceEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(16, verticalLinetoArgumentSequence_StartIndex);
    }

    return;
}
/* $ANTLR end verticalLinetoArgumentSequence */

/**
 * $ANTLR start verticalLineto
 * Svg.g:127:1: verticalLineto : ( 'V' | 'v' ) wsp verticalLinetoArgumentSequence ;
 */
Command* SvgParser::verticalLineto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER verticalLineto_StartIndex;
    verticalLineto_StartIndex = this->index();

    std::cout << "verticalLineto" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(17)))
    {
        return NULL;
    }

    VerticalLineToCommand* vertical = new VerticalLineToCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:127:15: ( ( 'V' | 'v' ) wsp verticalLinetoArgumentSequence )
        // Svg.g:128:5: ( 'V' | 'v' ) wsp verticalLinetoArgumentSequence
        {
            if (this->LA(1) == 25 || this->LA(1) == 38)
            {
                if (this->LA(1) == 25)
                {
                    vertical->setRelative(false);
                }
                else
                {
                    vertical->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(vertical);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto ruleverticalLinetoEx;
            }

            this->followPush(FOLLOW_wsp_in_verticalLineto814);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto ruleverticalLinetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(vertical);
                return NULL;
            }

            this->followPush(FOLLOW_verticalLinetoArgumentSequence_in_verticalLineto816);
            verticalLinetoArgumentSequence(args);

            this->followPop();
            if (this->hasException())
            {
                goto ruleverticalLinetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(vertical);
                return NULL;
            }
        }
    }

    goto ruleverticalLinetoEx; /* Prevent compiler warnings */
ruleverticalLinetoEx:
    ;

    vertical->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(17, verticalLineto_StartIndex);
    }

    return vertical;
}
/* $ANTLR end verticalLineto */

/**
 * $ANTLR start smoothCurvetoArgument
 * Svg.g:131:1: smoothCurvetoArgument : coordinatePair ( COMMA_WSP )? coordinatePair ;
 */
void SvgParser::smoothCurvetoArgument(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER smoothCurvetoArgument_StartIndex;
    smoothCurvetoArgument_StartIndex = this->index();

    std::cout << "smoothCurvetoArgument" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(18)))
    {
        return;
    }

    {
        // Svg.g:131:22: ( coordinatePair ( COMMA_WSP )? coordinatePair )
        // Svg.g:132:5: coordinatePair ( COMMA_WSP )? coordinatePair
        {
            this->followPush(FOLLOW_coordinatePair_in_smoothCurvetoArgument833);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothCurvetoArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:132:20: ( COMMA_WSP )?
            {
                int alt16 = 2;
                switch (this->LA(1))
                {
                    case COMMA_WSP:
                    {
                        alt16 = 1;
                    }
                        break;
                }

                switch (alt16)
                {
                    case 1: // Svg.g:132:20: COMMA_WSP
                    {
                        this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_smoothCurvetoArgument835);
                        if (this->hasException())
                        {
                            goto rulesmoothCurvetoArgumentEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;
                }
            }

            this->followPush(FOLLOW_coordinatePair_in_smoothCurvetoArgument838);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothCurvetoArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }
        }
    }

    goto rulesmoothCurvetoArgumentEx; /* Prevent compiler warnings */
rulesmoothCurvetoArgumentEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(18, smoothCurvetoArgument_StartIndex);
    }

    return;
}
/* $ANTLR end smoothCurvetoArgument */

/**
 * $ANTLR start smoothCurvetoArgumentSequence
 * Svg.g:135:1: smoothCurvetoArgumentSequence : smoothCurvetoArgument ( ( COMMA_WSP )? smoothCurvetoArgument )* ;
 */
void SvgParser::smoothCurvetoArgumentSequence(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER smoothCurvetoArgumentSequence_StartIndex;
    smoothCurvetoArgumentSequence_StartIndex = this->index();

    std::cout << "smoothCurvetoArgumentSequence" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(19)))
    {
        return;
    }

    {
        // Svg.g:135:30: ( smoothCurvetoArgument ( ( COMMA_WSP )? smoothCurvetoArgument )* )
        // Svg.g:136:5: smoothCurvetoArgument ( ( COMMA_WSP )? smoothCurvetoArgument )*
        {
            this->followPush(FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence855);
            smoothCurvetoArgument(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothCurvetoArgumentSequenceEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:136:27: ( ( COMMA_WSP )? smoothCurvetoArgument )*
            for (;;)
            {
                int alt18 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case NUMBER:
                            {
                                alt18 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case COMMA_WSP:
                    case NUMBER:
                    {
                        alt18 = 1;
                    }
                        break;
                }

                switch (alt18)
                {
                    case 1: // Svg.g:136:28: ( COMMA_WSP )? smoothCurvetoArgument
                    { // Svg.g:136:28: ( COMMA_WSP )?
                        {
                            int alt17 = 2;
                            switch (this->LA(1))
                            {
                                case COMMA_WSP:
                                {
                                    alt17 = 1;
                                }
                                    break;
                            }

                            switch (alt17)
                            {
                                case 1:
                                    // Svg.g:136:28: COMMA_WSP
                                {
                                    this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_smoothCurvetoArgumentSequence858);
                                    if (this->hasException())
                                    {
                                        goto rulesmoothCurvetoArgumentSequenceEx;
                                    }
                                    if (this->hasFailed())
                                    {
                                        return;
                                    }
                                }
                                    break;
                            }
                        }

                        this->followPush(FOLLOW_smoothCurvetoArgument_in_smoothCurvetoArgumentSequence861);
                        smoothCurvetoArgument(args);

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulesmoothCurvetoArgumentSequenceEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop18; /* break out of the loop */
                        break;
                }
            }
loop18:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto rulesmoothCurvetoArgumentSequenceEx; /* Prevent compiler warnings */
rulesmoothCurvetoArgumentSequenceEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(19, smoothCurvetoArgumentSequence_StartIndex);
    }

    return;
}
/* $ANTLR end smoothCurvetoArgumentSequence */

/**
 * $ANTLR start smoothCurveto
 * Svg.g:139:1: smoothCurveto : ( 'S' | 's' ) wsp smoothCurvetoArgumentSequence ;
 */
Command* SvgParser::smoothCurveto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER smoothCurveto_StartIndex;
    smoothCurveto_StartIndex = this->index();

    std::cout << "smoothrCurveto" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(20)))
    {
        return NULL;
    }

    SmoothCurveCommand* smoothCurve = new SmoothCurveCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:139:14: ( ( 'S' | 's' ) wsp smoothCurvetoArgumentSequence )
        // Svg.g:140:5: ( 'S' | 's' ) wsp smoothCurvetoArgumentSequence
        {
            if (this->LA(1) == 23 || this->LA(1) == 36)
            {
                if (this->LA(1) == 23)
                {
                    smoothCurve->setRelative(false);
                }
                else
                {
                    smoothCurve->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(smoothCurve);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto rulesmoothCurvetoEx;
            }

            this->followPush(FOLLOW_wsp_in_smoothCurveto894);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothCurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(smoothCurve);
                return NULL;
            }


            this->followPush(FOLLOW_smoothCurvetoArgumentSequence_in_smoothCurveto896);
            smoothCurvetoArgumentSequence(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothCurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(smoothCurve);
                return NULL;
            }
        }
    }

    goto rulesmoothCurvetoEx; /* Prevent compiler warnings */
rulesmoothCurvetoEx:
    ;

    smoothCurve->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(20, smoothCurveto_StartIndex);
    }

    return smoothCurve;
}
/* $ANTLR end smoothCurveto */

/**
 * $ANTLR start smoothQuadraticBezierCurvetoArgumentSequence
 * Svg.g:143:1: smoothQuadraticBezierCurvetoArgumentSequence : coordinatePair ( ( COMMA_WSP )? coordinatePair )* ;
 */
void SvgParser::smoothQuadraticBezierCurvetoArgumentSequence(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER smoothQuadraticBezierCurvetoArgumentSequence_StartIndex;
    smoothQuadraticBezierCurvetoArgumentSequence_StartIndex = this->index();

    std::cout << "smoothQuadraticBezierCurvetoArgumentSequence" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(21)))
    {
        return;
    }

    {
        // Svg.g:143:45: ( coordinatePair ( ( COMMA_WSP )? coordinatePair )* )
        // Svg.g:144:5: coordinatePair ( ( COMMA_WSP )? coordinatePair )*
        {
            this->followPush(FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence913);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothQuadraticBezierCurvetoArgumentSequenceEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:144:20: ( ( COMMA_WSP )? coordinatePair )*
            for (;;)
            {
                int alt20 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case NUMBER:
                            {
                                alt20 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case COMMA_WSP:
                    case NUMBER:
                    {
                        alt20 = 1;
                    }
                        break;
                }

                switch (alt20)
                {
                    case 1: // Svg.g:144:21: ( COMMA_WSP )? coordinatePair
                    { // Svg.g:144:21: ( COMMA_WSP )?
                        {
                            int alt19 = 2;
                            switch (this->LA(1))
                            {
                                case COMMA_WSP:
                                {
                                    alt19 = 1;
                                }
                                    break;
                            }

                            switch (alt19)
                            {
                                case 1: // Svg.g:144:21: COMMA_WSP
                                {
                                    this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_smoothQuadraticBezierCurvetoArgumentSequence916);
                                    if (this->hasException())
                                    {
                                        goto rulesmoothQuadraticBezierCurvetoArgumentSequenceEx;
                                    }
                                    if (this->hasFailed())
                                    {
                                        return;
                                    }
                                }
                                    break;
                            }
                        }

                        this->followPush(FOLLOW_coordinatePair_in_smoothQuadraticBezierCurvetoArgumentSequence919);
                        args.push_back(coordinatePair());

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulesmoothQuadraticBezierCurvetoArgumentSequenceEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop20; /* break out of the loop */
                        break;
                }
            }
loop20:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto rulesmoothQuadraticBezierCurvetoArgumentSequenceEx; /* Prevent compiler warnings */
rulesmoothQuadraticBezierCurvetoArgumentSequenceEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(21, smoothQuadraticBezierCurvetoArgumentSequence_StartIndex);
    }

    return;
}
/* $ANTLR end smoothQuadraticBezierCurvetoArgumentSequence */

/**
 * $ANTLR start smoothQuadraticBezierCurveto
 * Svg.g:147:1: smoothQuadraticBezierCurveto : ( 'T' | 't' ) wsp smoothQuadraticBezierCurvetoArgumentSequence ;
 */
Command* SvgParser::smoothQuadraticBezierCurveto()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER smoothQuadraticBezierCurveto_StartIndex;
    smoothQuadraticBezierCurveto_StartIndex = this->index();

    std::cout << "smoothQuadraticBezierCurveto" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(22)))
    {
        return NULL;
    }

    SmoothQuadraticBezierCurveToCommand* bezier = new SmoothQuadraticBezierCurveToCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:147:29: ( ( 'T' | 't' ) wsp smoothQuadraticBezierCurvetoArgumentSequence )
        // Svg.g:148:5: ( 'T' | 't' ) wsp smoothQuadraticBezierCurvetoArgumentSequence
        {
            if (this->LA(1) == 24 || this->LA(1) == 37)
            {
                if (this->LA(1) == 24)
                {
                    bezier->setRelative(false);
                }
                else
                {
                    bezier->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(bezier);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto rulesmoothQuadraticBezierCurvetoEx;
            }

            this->followPush(FOLLOW_wsp_in_smoothQuadraticBezierCurveto948);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothQuadraticBezierCurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(bezier);
                return NULL;
            }

            this->followPush(FOLLOW_smoothQuadraticBezierCurvetoArgumentSequence_in_smoothQuadraticBezierCurveto950);
            smoothQuadraticBezierCurvetoArgumentSequence(args);

            this->followPop();
            if (this->hasException())
            {
                goto rulesmoothQuadraticBezierCurvetoEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(bezier);
                return NULL;
            }
        }
    }

    goto rulesmoothQuadraticBezierCurvetoEx; /* Prevent compiler warnings */
rulesmoothQuadraticBezierCurvetoEx:
    ;

    bezier->setArgs(args);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(22, smoothQuadraticBezierCurveto_StartIndex);
    }

    return bezier;
}
/* $ANTLR end smoothQuadraticBezierCurveto */

/**
 * $ANTLR start ellipticalArcArgument
 * Svg.g:151:1: ellipticalArcArgument : coordinatePair wsp flag wsp flag wsp flag wsp coordinatePair ;
 */
void SvgParser::ellipticalArcArgument(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER ellipticalArcArgument_StartIndex;
    ellipticalArcArgument_StartIndex = this->index();

    std::cout << "ellipticalArcArguments" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(23)))
    {
        return;
    }

    {
        // Svg.g:151:22: ( coordinatePair wsp flag wsp flag wsp flag wsp coordinatePair )
        // Svg.g:152:5: coordinatePair wsp flag wsp flag wsp flag wsp coordinatePair
        {
            this->followPush(FOLLOW_coordinatePair_in_ellipticalArcArgument967);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_wsp_in_ellipticalArcArgument969);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_flag_in_ellipticalArcArgument971);
            args.push_back(flag());

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_wsp_in_ellipticalArcArgument973);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_flag_in_ellipticalArcArgument975);
            args.push_back(flag());

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_wsp_in_ellipticalArcArgument977);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_flag_in_ellipticalArcArgument979);
            args.push_back(flag());

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_wsp_in_ellipticalArcArgument981);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            this->followPush(FOLLOW_coordinatePair_in_ellipticalArcArgument983);
            args.push_back(coordinatePair());

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentEx;
            }
            if (this->hasFailed())
            {
                return;
            }
        }
    }

    goto ruleellipticalArcArgumentEx; /* Prevent compiler warnings */
ruleellipticalArcArgumentEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(23, ellipticalArcArgument_StartIndex);
    }

    return;
}
/* $ANTLR end ellipticalArcArgument */

/**
 * $ANTLR start ellipticalArcArgumentSequence
 * Svg.g:155:1: ellipticalArcArgumentSequence : ellipticalArcArgument ( ( COMMA_WSP )? ellipticalArcArgument )* ;
 */
void SvgParser::ellipticalArcArgumentSequence(std::vector<Argument*>& args)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER ellipticalArcArgumentSequence_StartIndex;
    ellipticalArcArgumentSequence_StartIndex = this->index();

    std::cout << "ellipticalArcArguments" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(24)))
    {
        return;
    }

    {
        // Svg.g:155:30: ( ellipticalArcArgument ( ( COMMA_WSP )? ellipticalArcArgument )* )
        // Svg.g:156:5: ellipticalArcArgument ( ( COMMA_WSP )? ellipticalArcArgument )*
        {
            this->followPush(FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1000);
            ellipticalArcArgument(args);

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcArgumentSequenceEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:156:27: ( ( COMMA_WSP )? ellipticalArcArgument )*
            for (;;)
            {
                int alt22 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case NUMBER:
                            {
                                alt22 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case COMMA_WSP:
                    case NUMBER:
                    {
                        alt22 = 1;
                    }
                        break;
                }

                switch (alt22)
                {
                    case 1: // Svg.g:156:28: ( COMMA_WSP )? ellipticalArcArgument
                    { // Svg.g:156:28: ( COMMA_WSP )?
                        {
                            int alt21 = 2;
                            switch (this->LA(1))
                            {
                                case COMMA_WSP:
                                {
                                    alt21 = 1;
                                }
                                    break;
                            }

                            switch (alt21)
                            {
                                case 1: // Svg.g:156:28: COMMA_WSP
                                {
                                    this->matchToken(COMMA_WSP, &FOLLOW_COMMA_WSP_in_ellipticalArcArgumentSequence1003);
                                    if (this->hasException())
                                    {
                                        goto ruleellipticalArcArgumentSequenceEx;
                                    }
                                    if (this->hasFailed())
                                    {
                                        return;
                                    }
                                }
                                    break;
                            }
                        }

                        this->followPush(FOLLOW_ellipticalArcArgument_in_ellipticalArcArgumentSequence1006);
                        ellipticalArcArgument(args);

                        this->followPop();
                        if (this->hasException())
                        {
                            goto ruleellipticalArcArgumentSequenceEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop22; /* break out of the loop */
                        break;
                }
            }
loop22:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto ruleellipticalArcArgumentSequenceEx; /* Prevent compiler warnings */
ruleellipticalArcArgumentSequenceEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(24, ellipticalArcArgumentSequence_StartIndex);
    }

    return;
}
/* $ANTLR end ellipticalArcArgumentSequence */

/**
 * $ANTLR start ellipticalArc
 * Svg.g:159:1: ellipticalArc : ( 'A' | 'a' ) wsp ellipticalArcArgumentSequence ;
 */
Command* SvgParser::ellipticalArc()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER ellipticalArc_StartIndex;
    ellipticalArc_StartIndex = this->index();

    std::cout << "ellipticalArc" << std::endl;

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(25)))
    {
        return NULL;
    }

    EllipticArcCommand* ellipse = new EllipticArcCommand();
    std::vector<Argument*> args;

    {
        // Svg.g:159:14: ( ( 'A' | 'a' ) wsp ellipticalArcArgumentSequence )
        // Svg.g:160:5: ( 'A' | 'a' ) wsp ellipticalArcArgumentSequence
        {
            if (this->LA(1) == 17 || this->LA(1) == 30)
            {
                if (this->LA(1) == 17)
                {
                    ellipse->setRelative(false);
                }
                else
                {
                    ellipse->setRelative(true);
                }

                this->consume();
                this->set_perror_recovery(false);
                this->set_failedflag(false);
            }
            else
            {
                if (this->get_backtracking() > 0)
                {
                    this->set_failedflag(true);
                    SAFE_DELETE(ellipse);
                    return NULL;
                }

                new ANTLR_Exception< SvgParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");
                this->get_exception()->set_expectingSet(NULL);

                goto ruleellipticalArcEx;
            }

            this->followPush(FOLLOW_wsp_in_ellipticalArc1039);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(ellipse);
                return NULL;
            }

            this->followPush(FOLLOW_ellipticalArcArgumentSequence_in_ellipticalArc1041);
            ellipticalArcArgumentSequence(args);

            this->followPop();
            if (this->hasException())
            {
                goto ruleellipticalArcEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(ellipse);
                return NULL;
            }
        }
    }

    goto ruleellipticalArcEx; /* Prevent compiler warnings */
ruleellipticalArcEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(25, ellipticalArc_StartIndex);
    }

    return ellipse;
}
/* $ANTLR end ellipticalArc */

/**
 * $ANTLR start drawtoCommand
 * Svg.g:163:1: drawtoCommand : ( closepath | lineto | curveto | quadraticBezierCurveto | horizontalLineto | verticalLineto | smoothCurveto | smoothQuadraticBezierCurveto | ellipticalArc );
 */
Command* SvgParser::drawtoCommand()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER drawtoCommand_StartIndex;
    drawtoCommand_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(26)))
    {
        return NULL;
    }

    Command* drawToCommand = NULL;

    {
        {
            //  Svg.g:163:14: ( closepath | lineto | curveto | quadraticBezierCurveto | horizontalLineto | verticalLineto | smoothCurveto | smoothQuadraticBezierCurveto | ellipticalArc )
            ANTLR_UINT32 alt23;

            alt23 = 9;

            switch (this->LA(1))
            {
                case 26:
                case 39:
                {
                    alt23 = 1;
                }
                    break;
                case 20:
                case 33:
                {
                    alt23 = 2;
                }
                    break;
                case 18:
                case 31:
                {
                    alt23 = 3;
                }
                    break;
                case 22:
                case 35:
                {
                    alt23 = 4;
                }
                    break;
                case 19:
                case 32:
                {
                    alt23 = 5;
                }
                    break;
                case 25:
                case 38:
                {
                    alt23 = 6;
                }
                    break;
                case 23:
                case 36:
                {
                    alt23 = 7;
                }
                    break;
                case 24:
                case 37:
                {
                    alt23 = 8;
                }
                    break;
                case 17:
                case 30:
                {
                    alt23 = 9;
                }
                    break;

                default:
                    if (this->get_backtracking() > 0)
                    {
                        this->set_failedflag(true);
                        return NULL;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< SvgParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType > (this->get_rec(), "");
                    ex->set_decisionNum(23);
                    ex->set_state(0);

                    goto ruledrawtoCommandEx;
            }

            switch (alt23)
            {
                case 1: // Svg.g:164:5: closepath
                {
                    this->followPush(FOLLOW_closepath_in_drawtoCommand1058);
                    drawToCommand = closepath();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 2: // Svg.g:165:7: lineto
                {
                    this->followPush(FOLLOW_lineto_in_drawtoCommand1066);
                    drawToCommand = lineto();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 3: // Svg.g:166:7: curveto
                {
                    this->followPush(FOLLOW_curveto_in_drawtoCommand1074);
                    drawToCommand = curveto();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 4: // Svg.g:167:7: quadraticBezierCurveto
                {
                    this->followPush(FOLLOW_quadraticBezierCurveto_in_drawtoCommand1082);
                    drawToCommand = quadraticBezierCurveto();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 5: // Svg.g:168:7: horizontalLineto
                {
                    this->followPush(FOLLOW_horizontalLineto_in_drawtoCommand1090);
                    drawToCommand = horizontalLineto();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 6: // Svg.g:169:7: verticalLineto
                {
                    this->followPush(FOLLOW_verticalLineto_in_drawtoCommand1098);
                    drawToCommand = verticalLineto();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 7: // Svg.g:170:7: smoothCurveto
                {
                    this->followPush(FOLLOW_smoothCurveto_in_drawtoCommand1106);
                    drawToCommand = smoothCurveto();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 8: // Svg.g:171:7: smoothQuadraticBezierCurveto
                {
                    this->followPush(FOLLOW_smoothQuadraticBezierCurveto_in_drawtoCommand1126);
                    drawToCommand = smoothQuadraticBezierCurveto();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
                case 9: // Svg.g:172:7: ellipticalArc
                {
                    this->followPush(FOLLOW_ellipticalArc_in_drawtoCommand1138);
                    drawToCommand = ellipticalArc();

                    this->followPop();
                    if (this->hasException())
                    {
                        goto ruledrawtoCommandEx;
                    }
                    if (this->hasFailed())
                    {
                        return NULL;
                    }
                }
                    break;
            }
        }
    }

    goto ruledrawtoCommandEx; /* Prevent compiler warnings */
ruledrawtoCommandEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(26, drawtoCommand_StartIndex);
    }

    return drawToCommand;
}
/* $ANTLR end drawtoCommand */

/**
 * $ANTLR start drawtoCommands
 * Svg.g:175:1: drawtoCommands : drawtoCommand ( drawtoCommand )* ;
 */
void SvgParser::drawtoCommands(std::vector<Command*>& commands)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER drawtoCommands_StartIndex;
    drawtoCommands_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(27)))
    {
        return;
    }

    {
        // Svg.g:175:15: ( drawtoCommand ( drawtoCommand )* )
        // Svg.g:176:5: drawtoCommand ( drawtoCommand )*
        {
            this->followPush(FOLLOW_drawtoCommand_in_drawtoCommands1155);
            commands.push_back(drawtoCommand());

            this->followPop();
            if (this->hasException())
            {
                goto ruledrawtoCommandsEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:176:19: ( drawtoCommand )*
            for (;;)
            {
                int alt24 = 2;
                switch (this->LA(1))
                {
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    {
                        alt24 = 1;
                    }
                        break;
                }

                switch (alt24)
                {
                    case 1: // Svg.g:176:20: drawtoCommand
                    {
                        this->followPush(FOLLOW_drawtoCommand_in_drawtoCommands1158);
                        commands.push_back(drawtoCommand());

                        this->followPop();
                        if (this->hasException())
                        {
                            goto ruledrawtoCommandsEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop24; /* break out of the loop */
                        break;
                }
            }
loop24:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto ruledrawtoCommandsEx; /* Prevent compiler warnings */
ruledrawtoCommandsEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(27, drawtoCommands_StartIndex);
    }

    return;
}
/* $ANTLR end drawtoCommands */

/**
 * $ANTLR start movetoDrawtoCommandGroup
 * Svg.g:179:1: movetoDrawtoCommandGroup : moveto wsp ( drawtoCommands )? ;
 */
Node* SvgParser::movetoDrawtoCommandGroup()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER movetoDrawtoCommandGroup_StartIndex;
    movetoDrawtoCommandGroup_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(28)))
    {
        return NULL;
    }

    std::cout << "movetoDrawtoCommandGroup" << std::endl;
    MovetoDrawtoCommandGroup* moveToGroup = new MovetoDrawtoCommandGroup();
    std::vector<Command*> nodes;

    {
        // Svg.g:179:25: ( moveto wsp ( drawtoCommands )? )
        // Svg.g:180:5: moveto wsp ( drawtoCommands )?
        {
            this->followPush(FOLLOW_moveto_in_movetoDrawtoCommandGroup1177);
            moveToGroup->setMoveTo(moveto());

            this->followPop();
            if (this->hasException())
            {
                goto rulemovetoDrawtoCommandGroupEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(moveToGroup);
                return NULL;
            }

            this->followPush(FOLLOW_wsp_in_movetoDrawtoCommandGroup1179);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulemovetoDrawtoCommandGroupEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(moveToGroup);
                return NULL;
            }

            // Svg.g:180:16: ( drawtoCommands )?
            {
                int alt25 = 2;
                switch (this->LA(1))
                {
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    {
                        alt25 = 1;
                    }
                        break;
                }

                switch (alt25)
                {
                    case 1: // Svg.g:180:16: drawtoCommands
                    {
                        this->followPush(FOLLOW_drawtoCommands_in_movetoDrawtoCommandGroup1181);
                        drawtoCommands(nodes);

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulemovetoDrawtoCommandGroupEx;
                        }
                        if (this->hasFailed())
                        {
                            SAFE_DELETE(moveToGroup);
                            return NULL;
                        }
                    }
                        break;
                }
            }
        }
    }

    goto rulemovetoDrawtoCommandGroupEx; /* Prevent compiler warnings */
rulemovetoDrawtoCommandGroupEx:
    ;

    moveToGroup->setDrawToCommands(nodes);

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(28, movetoDrawtoCommandGroup_StartIndex);
    }

    return moveToGroup;
}
/* $ANTLR end movetoDrawtoCommandGroup */

/**
 * $ANTLR start movetoDrawtoCommandGroups
 * Svg.g:183:1: movetoDrawtoCommandGroups : movetoDrawtoCommandGroup ( wsp movetoDrawtoCommandGroup )* ;
 */
void
SvgParser::movetoDrawtoCommandGroups(std::vector<Node*>& moveToCommandList)
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER movetoDrawtoCommandGroups_StartIndex;
    movetoDrawtoCommandGroups_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(29)))
    {
        return;
    }

    std::cout << "movetoDrawtoCommandGroups" << std::endl;

    {
        // Svg.g:183:26: ( movetoDrawtoCommandGroup ( wsp movetoDrawtoCommandGroup )* )
        // Svg.g:184:5: movetoDrawtoCommandGroup ( wsp movetoDrawtoCommandGroup )*
        {
            this->followPush(FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1199);
            moveToCommandList.push_back(movetoDrawtoCommandGroup());

            this->followPop();
            if (this->hasException())
            {
                goto rulemovetoDrawtoCommandGroupsEx;
            }
            if (this->hasFailed())
            {
                return;
            }

            // Svg.g:184:30: ( wsp movetoDrawtoCommandGroup )*
            for (;;)
            {
                int alt26 = 2;
                switch (this->LA(1))
                {
                    case 14:
                    case 27:
                    case 28:
                    case 29:
                    {
                        switch (this->LA(2))
                        {
                            case 21:
                            case 34:
                            {
                                alt26 = 1;
                            }
                                break;
                        }
                    }
                        break;
                    case 21:
                    case 34:
                    {
                        alt26 = 1;
                    }
                        break;
                }

                switch (alt26)
                {
                    case 1: // Svg.g:184:31: wsp movetoDrawtoCommandGroup
                    {
                        this->followPush(FOLLOW_wsp_in_movetoDrawtoCommandGroups1202);
                        wsp();

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulemovetoDrawtoCommandGroupsEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }

                        this->followPush(FOLLOW_movetoDrawtoCommandGroup_in_movetoDrawtoCommandGroups1204);
                        moveToCommandList.push_back(movetoDrawtoCommandGroup());

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulemovetoDrawtoCommandGroupsEx;
                        }
                        if (this->hasFailed())
                        {
                            return;
                        }
                    }
                        break;

                    default:
                        goto loop26; /* break out of the loop */
                        break;
                }
            }
loop26:
            ; /* Jump out to here if this rule does not match */
        }
    }

    goto rulemovetoDrawtoCommandGroupsEx; /* Prevent compiler warnings */
rulemovetoDrawtoCommandGroupsEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(29, movetoDrawtoCommandGroups_StartIndex);
    }

    return;
}
/* $ANTLR end movetoDrawtoCommandGroups */

/**
 * $ANTLR start svgPath
 * Svg.g:187:1: svgPath : wsp ( movetoDrawtoCommandGroups )? wsp ;
 */

Node* SvgParser::svgPath()
{
    SvgParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
    ANTLR_MARKER svgPath_StartIndex;
    svgPath_StartIndex = this->index();

    if ((this->get_backtracking() > 0) && (this->haveParsedRule(30)))
    {
        return NULL;
    }

    std::cout << "svgPath" << std::endl;

    SvgPath* svgPath = new SvgPath();
    std::vector<Node*> moveToGroups;

    {
        // Svg.g:187:8: ( wsp ( movetoDrawtoCommandGroups )? wsp )
        // Svg.g:188:5: wsp ( movetoDrawtoCommandGroups )? wsp
        {
            this->followPush(FOLLOW_wsp_in_svgPath1227);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulesvgPathEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(svgPath);
                return NULL;
            }

            // Svg.g:188:9: ( movetoDrawtoCommandGroups )?
            {
                int alt27 = 2;
                switch (this->LA(1))
                {
                    case 21:
                    case 34:
                    {
                        alt27 = 1;
                    }
                        break;
                }

                switch (alt27)
                {
                    case 1: // Svg.g:188:9: movetoDrawtoCommandGroups
                    {
                        this->followPush(FOLLOW_movetoDrawtoCommandGroups_in_svgPath1229);
                        movetoDrawtoCommandGroups(moveToGroups);

                        this->followPop();
                        if (this->hasException())
                        {
                            goto rulesvgPathEx;
                        }
                        if (this->hasFailed())
                        {
                            SAFE_DELETE(svgPath);
                            return NULL;
                        }
                    }
                        break;
                }
            }

            this->followPush(FOLLOW_wsp_in_svgPath1232);
            wsp();

            this->followPop();
            if (this->hasException())
            {
                goto rulesvgPathEx;
            }
            if (this->hasFailed())
            {
                SAFE_DELETE(svgPath);
                return NULL;
            }
        }

        svgPath->setMovetoDrawtoCommandGroups(moveToGroups);

    }

    goto rulesvgPathEx; /* Prevent compiler warnings */
rulesvgPathEx:
    ;

    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    if (this->get_backtracking() > 0)
    {
        this->memoize(30, svgPath_StartIndex);
    }

    return svgPath;
}
/* $ANTLR end svgPath */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */



/* End of code
 * =============================================================================
 */