/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Svg.g
 *     -                            On : 2013-03-23 01:23:54
 *     -                 for the lexer : SvgLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SvgLexer.hpp"
/* ----------------------------------------- */




/** String literals used by SvgLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR_UCHAR lit_1[] = {0x30, 0x78, antlr3::ANTLR_STRING_TERMINATOR};



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



SvgLexer::~SvgLexer()
{
}

void
SvgLexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Svg.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SvgLexer::getGrammarFileName()
{
    return fileName;
}

/** \brief Create a new lexer called SvgLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSvgLexer initialized for the lex start
 *     - Fail NULL
 */
SvgLexer::SvgLexer(StreamType* instream)
: SvgLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
    // See if we can create a new lexer with the standard constructor
    //
    this->init(instream);
}

/** \brief Create a new lexer called SvgLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSvgLexer initialized for the lex start
 *     - Fail NULL
 */
SvgLexer::SvgLexer(StreamType* instream, RecognizerSharedStateType* state)
: SvgLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
    this->init(instream);
}

void SvgLexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SvgLexer.h here so you can get a sense
     * of what goes where.
     */

}

void SvgLexer::insertIntoLiteralsQueue(std::string literal)
{
    m_identifiersQueue.push(literal);
    std::cout << literal << std::endl;
}

std::string SvgLexer::getIdentifierString()
{
    //std::cout << "Size: " << m_identifiersQueue.size() << std::endl;
    if (!m_identifiersQueue.empty())
    {
        std::string name = m_identifiersQueue.front();
        m_identifiersQueue.pop();
        std::cout << name << std::endl;
        return name;
    }
    else
    {
        throw std::runtime_error("No tokens in queue!");
    }
}

std::string SvgLexer::getIdentifierStringWithoutPop()
{
    std::cout << "Size: " << m_identifiersQueue.size() << std::endl;
    if (!m_identifiersQueue.empty())
    {
        std::string name = m_identifiersQueue.front();
        std::cout << name << std::endl;
        return name;
    }
    else
    {
        throw std::runtime_error("No tokens in queue!");
    }
}

double SvgLexer::convertStringToDouble(std::string& number)
{
    double temp = ::atof(number.c_str());
    return temp;
}

int SvgLexer::convertStringToInteger(std::string& number)
{
    int temp = ::atoi(number.c_str());
    return temp;
}



/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    16:5: ( ( WS )+ | ( WS )* ',' ( WS )* )
 */
static const ANTLR_INT32 dfa4_eot[4] ={
    -1, 3, -1, -1
};
static const ANTLR_INT32 dfa4_eof[4] ={
    -1, -1, -1, -1
};
static const ANTLR_INT32 dfa4_min[4] ={
    9, 9, -1, -1
};
static const ANTLR_INT32 dfa4_max[4] ={
    44, 44, -1, -1
};
static const ANTLR_INT32 dfa4_accept[4] ={
    -1, -1, 2, 1
};
static const ANTLR_INT32 dfa4_special[4] ={
    -1, -1, -1, -1
};

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa4_T_empty = NULL;

static const ANTLR_INT32 dfa4_T0[] ={
    1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
};


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa4_transitions[] ={
    dfa4_T0, dfa4_T0, NULL, NULL
};

/* Declare tracking structure for Cyclic DFA 4
 */
class SvgLexerCyclicDFA4 : public CyclicDFA< SvgLexerImplTraits, SvgLexer >, public SvgLexerTokens
{
public:
    typedef CyclicDFA< SvgLexerImplTraits, SvgLexer > BaseType;
    typedef BaseType::ContextType CtxType;

private:


public:

    SvgLexerCyclicDFA4(ANTLR_INT32 decisionNumber
            , const ANTLR_UCHAR* description
            , const ANTLR_INT32 * const eot
            , const ANTLR_INT32 * const eof
            , const ANTLR_INT32 * const min
            , const ANTLR_INT32 * const max
            , const ANTLR_INT32 * const accept
            , const ANTLR_INT32 * const special
            , const ANTLR_INT32 * const *const transition)
    : BaseType(decisionNumber, description, eot, eof, min, max, accept,
    special, transition)
    {

    }

};

static SvgLexerCyclicDFA4 cdfa4(
        4, /* Decision number of this dfa	    */
        /* Which decision this represents:   */
        (const ANTLR_UCHAR*) "16:5: ( ( WS )+ | ( WS )* ',' ( WS )* )",
        dfa4_eot, /* EOT table			    */
        dfa4_eof, /* EOF table			    */
        dfa4_min, /* Minimum tokens for each state    */
        dfa4_max, /* Maximum tokens for each state    */
        dfa4_accept, /* Accept table			    */
        dfa4_special, /* Special transition states	    */
        dfa4_transitions /* Table of transition tables	    */

        );


/* End of Cyclic DFA 4
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    20:10: ( INT | FLOAT )
 */
static const ANTLR_INT32 dfa6_eot[4] ={
    -1, 3, -1, -1
};
static const ANTLR_INT32 dfa6_eof[4] ={
    -1, -1, -1, -1
};
static const ANTLR_INT32 dfa6_min[4] ={
    46, 46, -1, -1
};
static const ANTLR_INT32 dfa6_max[4] ={
    57, 101, -1, -1
};
static const ANTLR_INT32 dfa6_accept[4] ={
    -1, -1, 2, 1
};
static const ANTLR_INT32 dfa6_special[4] ={
    -1, -1, -1, -1
};

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa6_T_empty = NULL;

static const ANTLR_INT32 dfa6_T0[] ={
    2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

static const ANTLR_INT32 dfa6_T1[] ={
    2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
};


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa6_transitions[] ={
    dfa6_T0, dfa6_T1, NULL, NULL
};

/* Declare tracking structure for Cyclic DFA 6
 */
class SvgLexerCyclicDFA6 : public CyclicDFA< SvgLexerImplTraits, SvgLexer >, public SvgLexerTokens
{
public:
    typedef CyclicDFA< SvgLexerImplTraits, SvgLexer > BaseType;
    typedef BaseType::ContextType CtxType;

private:


public:

    SvgLexerCyclicDFA6(ANTLR_INT32 decisionNumber
            , const ANTLR_UCHAR* description
            , const ANTLR_INT32 * const eot
            , const ANTLR_INT32 * const eof
            , const ANTLR_INT32 * const min
            , const ANTLR_INT32 * const max
            , const ANTLR_INT32 * const accept
            , const ANTLR_INT32 * const special
            , const ANTLR_INT32 * const *const transition)
    : BaseType(decisionNumber, description, eot, eof, min, max, accept,
    special, transition)
    {

    }

};

static SvgLexerCyclicDFA6 cdfa6(
        6, /* Decision number of this dfa	    */
        /* Which decision this represents:   */
        (const ANTLR_UCHAR*) "20:10: ( INT | FLOAT )",
        dfa6_eot, /* EOT table			    */
        dfa6_eof, /* EOF table			    */
        dfa6_min, /* Minimum tokens for each state    */
        dfa6_max, /* Maximum tokens for each state    */
        dfa6_accept, /* Accept table			    */
        dfa6_special, /* Special transition states	    */
        dfa6_transitions /* Table of transition tables	    */

        );


/* End of Cyclic DFA 6
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    41:1: fragment FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );
 */
static const ANTLR_INT32 dfa16_eot[5] ={
    -1, -1, -1, -1, -1
};
static const ANTLR_INT32 dfa16_eof[5] ={
    -1, -1, -1, -1, -1
};
static const ANTLR_INT32 dfa16_min[5] ={
    46, 46, -1, -1, -1
};
static const ANTLR_INT32 dfa16_max[5] ={
    57, 101, -1, -1, -1
};
static const ANTLR_INT32 dfa16_accept[5] ={
    -1, -1, 2, 1, 3
};
static const ANTLR_INT32 dfa16_special[5] ={
    -1, -1, -1, -1, -1
};

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa16_T_empty = NULL;

static const ANTLR_INT32 dfa16_T0[] ={
    3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
};

static const ANTLR_INT32 dfa16_T1[] ={
    2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa16_transitions[] ={
    dfa16_T1, dfa16_T0, NULL, NULL, NULL
};

/* Declare tracking structure for Cyclic DFA 16
 */
class SvgLexerCyclicDFA16 : public CyclicDFA< SvgLexerImplTraits, SvgLexer >, public SvgLexerTokens
{
public:
    typedef CyclicDFA< SvgLexerImplTraits, SvgLexer > BaseType;
    typedef BaseType::ContextType CtxType;

private:


public:

    SvgLexerCyclicDFA16(ANTLR_INT32 decisionNumber
            , const ANTLR_UCHAR* description
            , const ANTLR_INT32 * const eot
            , const ANTLR_INT32 * const eof
            , const ANTLR_INT32 * const min
            , const ANTLR_INT32 * const max
            , const ANTLR_INT32 * const accept
            , const ANTLR_INT32 * const special
            , const ANTLR_INT32 * const *const transition)
    : BaseType(decisionNumber, description, eot, eof, min, max, accept,
    special, transition)
    {

    }

};

static SvgLexerCyclicDFA16 cdfa16(
        16, /* Decision number of this dfa	    */
        /* Which decision this represents:   */
        (const ANTLR_UCHAR*) "41:1: fragment FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );",
        dfa16_eot, /* EOT table			    */
        dfa16_eof, /* EOF table			    */
        dfa16_min, /* Minimum tokens for each state    */
        dfa16_max, /* Maximum tokens for each state    */
        dfa16_accept, /* Accept table			    */
        dfa16_special, /* Special transition states	    */
        dfa16_transitions /* Table of transition tables	    */

        );


/* End of Cyclic DFA 16
 * ---------------------
 */
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 11:7: ( ' ' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__14
 *
 * Looks to match the characters the constitute the token T__14
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__14()
{
    ANTLR_UINT32 _type;



    _type = T__14;


    // Svg.g:11:7: ( ' ' )
    // Svg.g:11:9: ' '
    {
        this->matchc(' ');
        if (this->hasException())
        {
            goto ruleT__14Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__14Ex; /* Prevent compiler warnings */
ruleT__14Ex:
    ;

}
// $ANTLR end T__14

//   Comes from: 12:7: ( '0' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__15
 *
 * Looks to match the characters the constitute the token T__15
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__15()
{
    ANTLR_UINT32 _type;



    _type = T__15;


    // Svg.g:12:7: ( '0' )
    // Svg.g:12:9: '0'
    {
        this->matchc('0');
//        if (this->hasException())
//        {
//            goto ruleT__15Ex;
//        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__15Ex; /* Prevent compiler warnings */
ruleT__15Ex:
    ;

}
// $ANTLR end T__15

//   Comes from: 13:7: ( '1' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__16
 *
 * Looks to match the characters the constitute the token T__16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__16()
{
    ANTLR_UINT32 _type;



    _type = T__16;


    // Svg.g:13:7: ( '1' )
    // Svg.g:13:9: '1'
    {
        this->matchc('1');
        if (this->hasException())
        {
            goto ruleT__16Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__16Ex; /* Prevent compiler warnings */
ruleT__16Ex:
    ;

}
// $ANTLR end T__16

//   Comes from: 14:7: ( 'A' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__17
 *
 * Looks to match the characters the constitute the token T__17
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__17()
{
    ANTLR_UINT32 _type;



    _type = T__17;


    // Svg.g:14:7: ( 'A' )
    // Svg.g:14:9: 'A'
    {
        this->matchc('A');
        if (this->hasException())
        {
            goto ruleT__17Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__17Ex; /* Prevent compiler warnings */
ruleT__17Ex:
    ;

}
// $ANTLR end T__17

//   Comes from: 15:7: ( 'C' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__18
 *
 * Looks to match the characters the constitute the token T__18
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__18()
{
    ANTLR_UINT32 _type;



    _type = T__18;


    // Svg.g:15:7: ( 'C' )
    // Svg.g:15:9: 'C'
    {
        this->matchc('C');
        if (this->hasException())
        {
            goto ruleT__18Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__18Ex; /* Prevent compiler warnings */
ruleT__18Ex:
    ;

}
// $ANTLR end T__18

//   Comes from: 16:7: ( 'H' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__19
 *
 * Looks to match the characters the constitute the token T__19
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__19()
{
    ANTLR_UINT32 _type;



    _type = T__19;


    // Svg.g:16:7: ( 'H' )
    // Svg.g:16:9: 'H'
    {
        this->matchc('H');
        if (this->hasException())
        {
            goto ruleT__19Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__19Ex; /* Prevent compiler warnings */
ruleT__19Ex:
    ;

}
// $ANTLR end T__19

//   Comes from: 17:7: ( 'L' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__20
 *
 * Looks to match the characters the constitute the token T__20
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__20()
{
    ANTLR_UINT32 _type;



    _type = T__20;


    // Svg.g:17:7: ( 'L' )
    // Svg.g:17:9: 'L'
    {
        this->matchc('L');
        if (this->hasException())
        {
            goto ruleT__20Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__20Ex; /* Prevent compiler warnings */
ruleT__20Ex:
    ;

}
// $ANTLR end T__20

//   Comes from: 18:7: ( 'M' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__21
 *
 * Looks to match the characters the constitute the token T__21
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__21()
{
    ANTLR_UINT32 _type;



    _type = T__21;


    // Svg.g:18:7: ( 'M' )
    // Svg.g:18:9: 'M'
    {
        this->matchc('M');
        if (this->hasException())
        {
            goto ruleT__21Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__21Ex; /* Prevent compiler warnings */
ruleT__21Ex:
    ;

}
// $ANTLR end T__21

//   Comes from: 19:7: ( 'Q' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__22
 *
 * Looks to match the characters the constitute the token T__22
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__22()
{
    ANTLR_UINT32 _type;



    _type = T__22;


    // Svg.g:19:7: ( 'Q' )
    // Svg.g:19:9: 'Q'
    {
        this->matchc('Q');
        if (this->hasException())
        {
            goto ruleT__22Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__22Ex; /* Prevent compiler warnings */
ruleT__22Ex:
    ;

}
// $ANTLR end T__22

//   Comes from: 20:7: ( 'S' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__23
 *
 * Looks to match the characters the constitute the token T__23
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__23()
{
    ANTLR_UINT32 _type;



    _type = T__23;


    // Svg.g:20:7: ( 'S' )
    // Svg.g:20:9: 'S'
    {
        this->matchc('S');
        if (this->hasException())
        {
            goto ruleT__23Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__23Ex; /* Prevent compiler warnings */
ruleT__23Ex:
    ;

}
// $ANTLR end T__23

//   Comes from: 21:7: ( 'T' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__24
 *
 * Looks to match the characters the constitute the token T__24
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__24()
{
    ANTLR_UINT32 _type;



    _type = T__24;


    // Svg.g:21:7: ( 'T' )
    // Svg.g:21:9: 'T'
    {
        this->matchc('T');
        if (this->hasException())
        {
            goto ruleT__24Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__24Ex; /* Prevent compiler warnings */
ruleT__24Ex:
    ;

}
// $ANTLR end T__24

//   Comes from: 22:7: ( 'V' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__25
 *
 * Looks to match the characters the constitute the token T__25
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__25()
{
    ANTLR_UINT32 _type;



    _type = T__25;


    // Svg.g:22:7: ( 'V' )
    // Svg.g:22:9: 'V'
    {
        this->matchc('V');
        if (this->hasException())
        {
            goto ruleT__25Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__25Ex; /* Prevent compiler warnings */
ruleT__25Ex:
    ;

}
// $ANTLR end T__25

//   Comes from: 23:7: ( 'Z' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__26
 *
 * Looks to match the characters the constitute the token T__26
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__26()
{
    ANTLR_UINT32 _type;



    _type = T__26;


    // Svg.g:23:7: ( 'Z' )
    // Svg.g:23:9: 'Z'
    {
        this->matchc('Z');
        if (this->hasException())
        {
            goto ruleT__26Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__26Ex; /* Prevent compiler warnings */
ruleT__26Ex:
    ;

}
// $ANTLR end T__26

//   Comes from: 24:7: ( '\\n' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__27
 *
 * Looks to match the characters the constitute the token T__27
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__27()
{
    ANTLR_UINT32 _type;



    _type = T__27;


    // Svg.g:24:7: ( '\\n' )
    // Svg.g:24:9: '\\n'
    {
        this->matchc('\n');
        if (this->hasException())
        {
            goto ruleT__27Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__27Ex; /* Prevent compiler warnings */
ruleT__27Ex:
    ;

}
// $ANTLR end T__27

//   Comes from: 25:7: ( '\\r' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__28
 *
 * Looks to match the characters the constitute the token T__28
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__28()
{
    ANTLR_UINT32 _type;



    _type = T__28;


    // Svg.g:25:7: ( '\\r' )
    // Svg.g:25:9: '\\r'
    {
        this->matchc('\r');
        if (this->hasException())
        {
            goto ruleT__28Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__28Ex; /* Prevent compiler warnings */
ruleT__28Ex:
    ;

}
// $ANTLR end T__28

//   Comes from: 26:7: ( '\\t' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__29
 *
 * Looks to match the characters the constitute the token T__29
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__29()
{
    ANTLR_UINT32 _type;



    _type = T__29;


    // Svg.g:26:7: ( '\\t' )
    // Svg.g:26:9: '\\t'
    {
        this->matchc('\t');
        if (this->hasException())
        {
            goto ruleT__29Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__29Ex; /* Prevent compiler warnings */
ruleT__29Ex:
    ;

}
// $ANTLR end T__29

//   Comes from: 27:7: ( 'a' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__30
 *
 * Looks to match the characters the constitute the token T__30
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__30()
{
    ANTLR_UINT32 _type;



    _type = T__30;


    // Svg.g:27:7: ( 'a' )
    // Svg.g:27:9: 'a'
    {
        this->matchc('a');
        if (this->hasException())
        {
            goto ruleT__30Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__30Ex; /* Prevent compiler warnings */
ruleT__30Ex:
    ;

}
// $ANTLR end T__30

//   Comes from: 28:7: ( 'c' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__31
 *
 * Looks to match the characters the constitute the token T__31
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__31()
{
    ANTLR_UINT32 _type;



    _type = T__31;


    // Svg.g:28:7: ( 'c' )
    // Svg.g:28:9: 'c'
    {
        this->matchc('c');
        if (this->hasException())
        {
            goto ruleT__31Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__31Ex; /* Prevent compiler warnings */
ruleT__31Ex:
    ;

}
// $ANTLR end T__31

//   Comes from: 29:7: ( 'h' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__32
 *
 * Looks to match the characters the constitute the token T__32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__32()
{
    ANTLR_UINT32 _type;



    _type = T__32;


    // Svg.g:29:7: ( 'h' )
    // Svg.g:29:9: 'h'
    {
        this->matchc('h');
        if (this->hasException())
        {
            goto ruleT__32Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__32Ex; /* Prevent compiler warnings */
ruleT__32Ex:
    ;

}
// $ANTLR end T__32

//   Comes from: 30:7: ( 'l' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__33
 *
 * Looks to match the characters the constitute the token T__33
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__33()
{
    ANTLR_UINT32 _type;



    _type = T__33;


    // Svg.g:30:7: ( 'l' )
    // Svg.g:30:9: 'l'
    {
        this->matchc('l');
        if (this->hasException())
        {
            goto ruleT__33Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__33Ex; /* Prevent compiler warnings */
ruleT__33Ex:
    ;

}
// $ANTLR end T__33

//   Comes from: 31:7: ( 'm' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__34
 *
 * Looks to match the characters the constitute the token T__34
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__34()
{
    ANTLR_UINT32 _type;



    _type = T__34;


    // Svg.g:31:7: ( 'm' )
    // Svg.g:31:9: 'm'
    {
        this->matchc('m');
        if (this->hasException())
        {
            goto ruleT__34Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__34Ex; /* Prevent compiler warnings */
ruleT__34Ex:
    ;

}
// $ANTLR end T__34

//   Comes from: 32:7: ( 'q' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__35
 *
 * Looks to match the characters the constitute the token T__35
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__35()
{
    ANTLR_UINT32 _type;



    _type = T__35;


    // Svg.g:32:7: ( 'q' )
    // Svg.g:32:9: 'q'
    {
        this->matchc('q');
        if (this->hasException())
        {
            goto ruleT__35Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__35Ex; /* Prevent compiler warnings */
ruleT__35Ex:
    ;

}
// $ANTLR end T__35

//   Comes from: 33:7: ( 's' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__36
 *
 * Looks to match the characters the constitute the token T__36
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__36()
{
    ANTLR_UINT32 _type;



    _type = T__36;


    // Svg.g:33:7: ( 's' )
    // Svg.g:33:9: 's'
    {
        this->matchc('s');
        if (this->hasException())
        {
            goto ruleT__36Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__36Ex; /* Prevent compiler warnings */
ruleT__36Ex:
    ;

}
// $ANTLR end T__36

//   Comes from: 34:7: ( 't' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__37
 *
 * Looks to match the characters the constitute the token T__37
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__37()
{
    ANTLR_UINT32 _type;



    _type = T__37;


    // Svg.g:34:7: ( 't' )
    // Svg.g:34:9: 't'
    {
        this->matchc('t');
        if (this->hasException())
        {
            goto ruleT__37Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__37Ex; /* Prevent compiler warnings */
ruleT__37Ex:
    ;

}
// $ANTLR end T__37

//   Comes from: 35:7: ( 'v' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__38
 *
 * Looks to match the characters the constitute the token T__38
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__38()
{
    ANTLR_UINT32 _type;



    _type = T__38;


    // Svg.g:35:7: ( 'v' )
    // Svg.g:35:9: 'v'
    {
        this->matchc('v');
        if (this->hasException())
        {
            goto ruleT__38Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__38Ex; /* Prevent compiler warnings */
ruleT__38Ex:
    ;

}
// $ANTLR end T__38

//   Comes from: 36:7: ( 'z' )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__39
 *
 * Looks to match the characters the constitute the token T__39
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mT__39()
{
    ANTLR_UINT32 _type;



    _type = T__39;


    // Svg.g:36:7: ( 'z' )
    // Svg.g:36:9: 'z'
    {
        this->matchc('z');
        if (this->hasException())
        {
            goto ruleT__39Ex;
        }


    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__39Ex; /* Prevent compiler warnings */
ruleT__39Ex:
    ;

}
// $ANTLR end T__39

//   Comes from: 15:10: ( ( ( WS )+ | ( WS )* ',' ( WS )* ) )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMA_WSP
 *
 * Looks to match the characters the constitute the token COMMA_WSP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mCOMMA_WSP()
{
    ANTLR_UINT32 _type;



    _type = COMMA_WSP;


    // Svg.g:15:10: ( ( ( WS )+ | ( WS )* ',' ( WS )* ) )
    // Svg.g:16:5: ( ( WS )+ | ( WS )* ',' ( WS )* )
    {
        // Svg.g:16:5: ( ( WS )+ | ( WS )* ',' ( WS )* )
        {
            int alt4 = 2;
            alt4 = cdfa4.predict(this, this->get_rec(), this->get_istream(), cdfa4);
            if (this->hasException())
            {
                goto ruleCOMMA_WSPEx;
            }

            switch (alt4)
            {
                case 1:
                    // Svg.g:16:6: ( WS )+
                {
                    // Svg.g:16:6: ( WS )+
                    {
                        int cnt1 = 0;

                        for (;;)
                        {
                            int alt1 = 2;
                            switch (this->LA(1))
                            {
                                case '\t':
                                case '\n':
                                case '\r':
                                case ' ':
                                {
                                    alt1 = 1;
                                }
                                    break;

                            }

                            switch (alt1)
                            {
                                case 1:
                                    // Svg.g:
                                {
                                    if (((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || this->LA(1) == '\r' || this->LA(1) == ' ')
                                    {
                                        this->consume();
                                    }
                                    else
                                    {
                                        new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                                        this->recover();
                                        goto ruleCOMMA_WSPEx;
                                    }


                                }
                                    break;

                                default:

                                    if (cnt1 >= 1)
                                    {
                                        goto loop1;
                                    }
                                    /* mismatchedSetEx()
                                     */
                                    new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                                    goto ruleCOMMA_WSPEx;
                            }
                            cnt1++;
                        }
loop1:
                        ; /* Jump to here if this rule does not match */
                    }

                }
                    break;
                case 2:
                    // Svg.g:16:12: ( WS )* ',' ( WS )*
                {
                    // Svg.g:16:12: ( WS )*

                    for (;;)
                    {
                        int alt2 = 2;
                        switch (this->LA(1))
                        {
                            case '\t':
                            case '\n':
                            case '\r':
                            case ' ':
                            {
                                alt2 = 1;
                            }
                                break;

                        }

                        switch (alt2)
                        {
                            case 1:
                                // Svg.g:
                            {
                                if (((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || this->LA(1) == '\r' || this->LA(1) == ' ')
                                {
                                    this->consume();
                                }
                                else
                                {
                                    new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                                    this->recover();
                                    goto ruleCOMMA_WSPEx;
                                }


                            }
                                break;

                            default:
                                goto loop2; /* break out of the loop */
                                break;
                        }
                    }
loop2:
                    ; /* Jump out to here if this rule does not match */


                    this->matchc(',');
                    if (this->hasException())
                    {
                        goto ruleCOMMA_WSPEx;
                    }


                    // Svg.g:16:20: ( WS )*

                    for (;;)
                    {
                        int alt3 = 2;
                        switch (this->LA(1))
                        {
                            case '\t':
                            case '\n':
                            case '\r':
                            case ' ':
                            {
                                alt3 = 1;
                            }
                                break;

                        }

                        switch (alt3)
                        {
                            case 1:
                                // Svg.g:
                            {
                                if (((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || this->LA(1) == '\r' || this->LA(1) == ' ')
                                {
                                    this->consume();
                                }
                                else
                                {
                                    new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                                    this->recover();
                                    goto ruleCOMMA_WSPEx;
                                }


                            }
                                break;

                            default:
                                goto loop3; /* break out of the loop */
                                break;
                        }
                    }
loop3:
                    ; /* Jump out to here if this rule does not match */


                }
                    break;

            }
        }

    }

    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOMMA_WSPEx; /* Prevent compiler warnings */
ruleCOMMA_WSPEx:
    ;

}
// $ANTLR end COMMA_WSP

//   Comes from: 19:7: ( ( '-' )? ( INT | FLOAT ) )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NUMBER
 *
 * Looks to match the characters the constitute the token NUMBER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mNUMBER()
{
    ANTLR_UINT32 _type;



    _type = NUMBER;
    std::string number;


    // Svg.g:19:7: ( ( '-' )? ( INT | FLOAT ) )
    // Svg.g:20:5: ( '-' )? ( INT | FLOAT )
    {
        // Svg.g:20:5: ( '-' )?
        {
            int alt5 = 2;
            switch (this->LA(1))
            {
                case '-':
                {
                    alt5 = 1;
                }
                    break;
            }

            switch (alt5)
            {
                case 1:
                    // Svg.g:20:5: '-'
                {
                    this->matchc('-');
                    if (this->hasException())
                    {
                        goto ruleNUMBEREx;
                    }
                    number = '-';

                }
                    break;

            }
        }

        // Svg.g:20:10: ( INT | FLOAT )
        {
            int alt6 = 2;
            alt6 = cdfa6.predict(this, this->get_rec(), this->get_istream(), cdfa6);
            if (this->hasException())
            {
                goto ruleNUMBEREx;
            }

            switch (alt6)
            {
                case 1:
                    // Svg.g:20:11: INT
                {                    
                    /* 20:11: INT */
                    mINT(number);
                    if (this->hasException())
                    {
                        goto ruleNUMBEREx;
                    }



                }
                    break;
                case 2:
                    // Svg.g:20:17: FLOAT
                {
                    /* 20:17: FLOAT */
                    mFLOAT(number);
                    if (this->hasException())
                    {
                        goto ruleNUMBEREx;
                    }



                }
                    break;

            }
        }

    }

    insertIntoLiteralsQueue(number);
    
    this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNUMBEREx; /* Prevent compiler warnings */
ruleNUMBEREx:
    ;

}
// $ANTLR end NUMBER

//   Comes from: 24:4: ( DIGITS )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT
 *
 * Looks to match the characters the constitute the token INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mINT(std::string& number)
{
    ANTLR_UINT32 _type;

    std::cout << "INT" << std::endl;


    // Svg.g:24:4: ( DIGITS )
    // Svg.g:25:2: DIGITS
    {
        /* 25:2: DIGITS */
        mDIGITS(number);
        if (this->hasException())
        {
            goto ruleINTEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleINTEx; /* Prevent compiler warnings */
ruleINTEx:
    ;

}
// $ANTLR end INT

//   Comes from: 29:7: ( ( '0' .. '9' )+ )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGITS
 *
 * Looks to match the characters the constitute the token DIGITS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mDIGITS(std::string& number)
{
    ANTLR_UINT32 _type;




    // Svg.g:29:7: ( ( '0' .. '9' )+ )
    // Svg.g:30:5: ( '0' .. '9' )+
    {
        // Svg.g:30:5: ( '0' .. '9' )+
        {
            int cnt7 = 0;

            for (;;)
            {
                int alt7 = 2;
                switch (this->LA(1))
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    {
                        alt7 = 1;
                    }
                        break;

                }

                switch (alt7)
                {
                    case 1:
                        // Svg.g:
                    {
                        if (((this->LA(1) >= '0') && (this->LA(1) <= '9')))
                        {
                            if (this->LA(1) == '0')
                                number += '0';
                            else if (this->LA(1) == '1')
                                number += '1';
                            else if (this->LA(1) == '2')
                                number += '2';
                            else if (this->LA(1) == '3')
                                number += '3';
                            else if (this->LA(1) == '4')
                                number += '4';
                            else if (this->LA(1) == '5')
                                number += '5';
                            else if (this->LA(1) == '6')
                                number += '6';
                            else if (this->LA(1) == '7')
                                number += '7';
                            else if (this->LA(1) == '8')
                                number += '8';
                            else
                                number += '9';
                            this->consume();
                        }
                        else
                        {
                            new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                            this->recover();
                            goto ruleDIGITSEx;
                        }


                    }
                        break;

                    default:                       
                        if (cnt7 >= 1)
                        {
                            goto loop7;
                        }
                        /* mismatchedSetEx()
                         */
                        new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                        goto ruleDIGITSEx;
                }
                cnt7++;
            }
loop7:
            ; /* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleDIGITSEx; /* Prevent compiler warnings */
ruleDIGITSEx:
    ;

}
// $ANTLR end DIGITS

//   Comes from: 33:13: ( '0' ( '0' .. '7' )+ )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_DIGITS
 *
 * Looks to match the characters the constitute the token OCTAL_DIGITS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mOCTAL_DIGITS(std::string& number)
{
    ANTLR_UINT32 _type;




    // Svg.g:33:13: ( '0' ( '0' .. '7' )+ )
    // Svg.g:34:5: '0' ( '0' .. '7' )+
    {
        this->matchc('0');
        if (this->hasException())
        {
            goto ruleOCTAL_DIGITSEx;
        }


        // Svg.g:34:9: ( '0' .. '7' )+
        {
            int cnt8 = 0;

            for (;;)
            {
                int alt8 = 2;
                switch (this->LA(1))
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    {
                        alt8 = 1;
                    }
                        break;

                }

                switch (alt8)
                {
                    case 1:
                        // Svg.g:
                    {
                        if (((this->LA(1) >= '0') && (this->LA(1) <= '7')))
                        {
                            this->consume();
                        }
                        else
                        {
                            new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                            this->recover();
                            goto ruleOCTAL_DIGITSEx;
                        }


                    }
                        break;

                    default:

                        if (cnt8 >= 1)
                        {
                            goto loop8;
                        }
                        /* mismatchedSetEx()
                         */
                        new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                        goto ruleOCTAL_DIGITSEx;
                }
                cnt8++;
            }
loop8:
            ; /* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleOCTAL_DIGITSEx; /* Prevent compiler warnings */
ruleOCTAL_DIGITSEx:
    ;

}
// $ANTLR end OCTAL_DIGITS

//   Comes from: 37:11: ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGITS
 *
 * Looks to match the characters the constitute the token HEX_DIGITS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mHEX_DIGITS(std::string& number)
{
    ANTLR_UINT32 _type;




    // Svg.g:37:11: ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ )
    // Svg.g:38:5: '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
    {
        this->matchs(lit_1);
        if (this->hasException())
        {
            goto ruleHEX_DIGITSEx;
        }




        // Svg.g:38:10: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
        {
            int cnt9 = 0;

            for (;;)
            {
                int alt9 = 2;
                switch (this->LA(1))
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'f':
                    {
                        alt9 = 1;
                    }
                        break;

                }

                switch (alt9)
                {
                    case 1:
                        // Svg.g:
                    {
                        if (((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'F')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'f')))
                        {
                            this->consume();
                        }
                        else
                        {
                            new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                            this->recover();
                            goto ruleHEX_DIGITSEx;
                        }


                    }
                        break;

                    default:

                        if (cnt9 >= 1)
                        {
                            goto loop9;
                        }
                        /* mismatchedSetEx()
                         */
                        new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                        goto ruleHEX_DIGITSEx;
                }
                cnt9++;
            }
loop9:
            ; /* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITSEx; /* Prevent compiler warnings */
ruleHEX_DIGITSEx:
    ;

}
// $ANTLR end HEX_DIGITS

//   Comes from: 41:6: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mFLOAT(std::string& number)
{
    ANTLR_UINT32 _type;


    std::cout << "Float" << std::endl;

    {
        //  Svg.g:41:6: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )

        ANTLR_UINT32 alt16;

        alt16 = 3;

        alt16 = cdfa16.predict(this, this->get_rec(), this->get_istream(), cdfa16);
        if (this->hasException())
        {
            goto ruleFLOATEx;
        }

        switch (alt16)
        {
            case 1:
                // Svg.g:42:5: ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )?
            {
                // Svg.g:42:5: ( '0' .. '9' )+
                {
                    int cnt10 = 0;

                    for (;;)
                    {
                        int alt10 = 2;
                        switch (this->LA(1))
                        {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            {
                                alt10 = 1;
                            }
                                break;

                        }

                        switch (alt10)
                        {
                            case 1:
                                // Svg.g:
                            {
                                if (((this->LA(1) >= '0') && (this->LA(1) <= '9')))
                                {
                                    if (this->LA(1) == '0')
                                        number += '0';
                                    else if (this->LA(1) == '1')
                                        number += '1';
                                    else if (this->LA(1) == '2')
                                        number += '2';
                                    else if (this->LA(1) == '3')
                                        number += '3';
                                    else if (this->LA(1) == '4')
                                        number += '4';
                                    else if (this->LA(1) == '5')
                                        number += '5';
                                    else if (this->LA(1) == '6')
                                        number += '6';
                                    else if (this->LA(1) == '7')
                                        number += '7';
                                    else if (this->LA(1) == '8')
                                        number += '8';
                                    else
                                        number += '9';
                                    this->consume();
                                }
                                else
                                {
                                    new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                                    this->recover();
                                    goto ruleFLOATEx;
                                }


                            }
                                break;

                            default:

                                if (cnt10 >= 1)
                                {
                                    goto loop10;
                                }
                                /* mismatchedSetEx()
                                 */
                                new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                                goto ruleFLOATEx;
                        }
                        cnt10++;
                    }
loop10:
                    ; /* Jump to here if this rule does not match */
                }

                this->matchc('.');                
                if (this->hasException())
                {
                    goto ruleFLOATEx;
                }

                number += '.';  

                // Svg.g:42:21: ( '0' .. '9' )*

                for (;;)
                {
                    int alt11 = 2;
                    switch (this->LA(1))
                    {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        {
                            alt11 = 1;
                        }
                            break;

                    }

                    switch (alt11)
                    {
                        case 1:
                            // Svg.g:
                        {
                            if (((this->LA(1) >= '0') && (this->LA(1) <= '9')))
                            {
                                if (this->LA(1) == '0')
                                    number += '0';
                                else if (this->LA(1) == '1')
                                    number += '1';
                                else if (this->LA(1) == '2')
                                    number += '2';
                                else if (this->LA(1) == '3')
                                    number += '3';
                                else if (this->LA(1) == '4')
                                    number += '4';
                                else if (this->LA(1) == '5')
                                    number += '5';
                                else if (this->LA(1) == '6')
                                    number += '6';
                                else if (this->LA(1) == '7')
                                    number += '7';
                                else if (this->LA(1) == '8')
                                    number += '8';
                                else
                                    number += '9';
                                this->consume();
                            }
                            else
                            {
                                new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                                this->recover();
                                goto ruleFLOATEx;
                            }


                        }
                            break;

                        default:
                            goto loop11; /* break out of the loop */
                            break;
                    }
                }
loop11:
                ; /* Jump out to here if this rule does not match */


                // Svg.g:42:33: ( EXPONENT )?
                {
                    int alt12 = 2;
                    switch (this->LA(1))
                    {
                        case 'E':
                        case 'e':
                        {
                            alt12 = 1;
                        }
                            break;
                    }

                    switch (alt12)
                    {
                        case 1:
                            // Svg.g:42:33: EXPONENT
                        {
                            /* 42:33: EXPONENT */
                            mEXPONENT(number);
                            if (this->hasException())
                            {
                                goto ruleFLOATEx;
                            }



                        }
                            break;

                    }
                }

            }
                break;
            case 2:
                // Svg.g:43:7: '.' ( '0' .. '9' )+ ( EXPONENT )?
            {
                this->matchc('.');
                if (this->hasException())
                {
                    goto ruleFLOATEx;
                }


                // Svg.g:43:11: ( '0' .. '9' )+
                {
                    int cnt13 = 0;

                    for (;;)
                    {
                        int alt13 = 2;
                        switch (this->LA(1))
                        {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            {
                                alt13 = 1;
                            }
                                break;

                        }

                        switch (alt13)
                        {
                            case 1:
                                // Svg.g:
                            {
                                if (((this->LA(1) >= '0') && (this->LA(1) <= '9')))
                                {
                                    if (this->LA(1) == '0')
                                        number += '0';
                                    else if (this->LA(1) == '1')
                                        number += '1';
                                    else if (this->LA(1) == '2')
                                        number += '2';
                                    else if (this->LA(1) == '3')
                                        number += '3';
                                    else if (this->LA(1) == '4')
                                        number += '4';
                                    else if (this->LA(1) == '5')
                                        number += '5';
                                    else if (this->LA(1) == '6')
                                        number += '6';
                                    else if (this->LA(1) == '7')
                                        number += '7';
                                    else if (this->LA(1) == '8')
                                        number += '8';
                                    else
                                        number += '9';
                                    this->consume();
                                }
                                else
                                {
                                    new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                                    this->recover();
                                    goto ruleFLOATEx;
                                }


                            }
                                break;

                            default:

                                if (cnt13 >= 1)
                                {
                                    goto loop13;
                                }
                                /* mismatchedSetEx()
                                 */
                                new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                                goto ruleFLOATEx;
                        }
                        cnt13++;
                    }
loop13:
                    ; /* Jump to here if this rule does not match */
                }

                // Svg.g:43:23: ( EXPONENT )?
                {
                    int alt14 = 2;
                    switch (this->LA(1))
                    {
                        case 'E':
                        case 'e':
                        {
                            alt14 = 1;
                        }
                            break;
                    }

                    switch (alt14)
                    {
                        case 1:
                            // Svg.g:43:23: EXPONENT
                        {
                            /* 43:23: EXPONENT */
                            mEXPONENT(number);
                            if (this->hasException())
                            {
                                goto ruleFLOATEx;
                            }



                        }
                            break;

                    }
                }

            }
                break;
            case 3:
                // Svg.g:44:7: ( '0' .. '9' )+ EXPONENT
            {
                // Svg.g:44:7: ( '0' .. '9' )+
                {
                    int cnt15 = 0;

                    for (;;)
                    {
                        int alt15 = 2;
                        switch (this->LA(1))
                        {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            {
                                alt15 = 1;
                            }
                                break;

                        }

                        switch (alt15)
                        {
                            case 1:
                                // Svg.g:
                            {
                                if (((this->LA(1) >= '0') && (this->LA(1) <= '9')))
                                {
                                    if (this->LA(1) == '0')
                                        number += '0';
                                    else if (this->LA(1) == '1')
                                        number += '1';
                                    else if (this->LA(1) == '2')
                                        number += '2';
                                    else if (this->LA(1) == '3')
                                        number += '3';
                                    else if (this->LA(1) == '4')
                                        number += '4';
                                    else if (this->LA(1) == '5')
                                        number += '5';
                                    else if (this->LA(1) == '6')
                                        number += '6';
                                    else if (this->LA(1) == '7')
                                        number += '7';
                                    else if (this->LA(1) == '8')
                                        number += '8';
                                    else
                                        number += '9';
                                    this->consume();
                                }
                                else
                                {
                                    new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                                    this->recover();
                                    goto ruleFLOATEx;
                                }


                            }
                                break;

                            default:

                                if (cnt15 >= 1)
                                {
                                    goto loop15;
                                }
                                /* mismatchedSetEx()
                                 */
                                new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                                goto ruleFLOATEx;
                        }
                        cnt15++;
                    }
loop15:
                    ; /* Jump to here if this rule does not match */
                }

                /* 44:7: ( '0' .. '9' )+ EXPONENT */
                mEXPONENT(number);
                if (this->hasException())
                {
                    goto ruleFLOATEx;
                }



            }
                break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleFLOATEx; /* Prevent compiler warnings */
ruleFLOATEx:
    ;

}
// $ANTLR end FLOAT

//   Comes from: 48:5: ( ( '0' | '1' ) )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLAG
 *
 * Looks to match the characters the constitute the token FLAG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mFLAG()
{
    ANTLR_UINT32 _type;


    std::string number;

    // Svg.g:48:5: ( ( '0' | '1' ) )
    // Svg.g:
    {
        if (((this->LA(1) >= '0') && (this->LA(1) <= '1')))
        {
            if (this->LA(1) == '0')
                number = '0';
            else
                number = '1';

            this->consume();
        }
        else
        {
            new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

            this->recover();
            goto ruleFLAGEx;
        }


    }
    insertIntoLiteralsQueue(number);

    // This is where rules clean up and exit
    //
    goto ruleFLAGEx; /* Prevent compiler warnings */
ruleFLAGEx:
    ;

}
// $ANTLR end FLAG

//   Comes from: 53:4: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mWS()
{
    ANTLR_UINT32 _type;




    // Svg.g:53:4: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
    // Svg.g:
    {
        if (((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || this->LA(1) == '\r' || this->LA(1) == ' ')
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

            this->recover();
            goto ruleWSEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
ruleWSEx:
    ;

}
// $ANTLR end WS

//   Comes from: 68:9: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )

/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SvgLexer::mEXPONENT(std::string& number)
{
    ANTLR_UINT32 _type;




    // Svg.g:68:9: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // Svg.g:69:5: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if (this->LA(1) == 'E' || this->LA(1) == 'e')
        {
            number += 'e';
            this->consume();
        }
        else
        {
            new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

            this->recover();
            goto ruleEXPONENTEx;
        }


        // Svg.g:69:15: ( '+' | '-' )?
        {
            int alt17 = 2;
            switch (this->LA(1))
            {
                case '+':
                case '-':
                {
                    alt17 = 1;
                }
                    break;
            }

            switch (alt17)
            {
                case 1:
                    // Svg.g:
                {
                    if (this->LA(1) == '+' || this->LA(1) == '-')
                    {
                        if (this->LA(1) == '-')
                        {
                            number += '-';
                        }
                        this->consume();
                    }
                    else
                    {
                        new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                        this->recover();
                        goto ruleEXPONENTEx;
                    }


                }
                    break;

            }
        }

        // Svg.g:69:26: ( '0' .. '9' )+
        {
            int cnt18 = 0;

            for (;;)
            {
                int alt18 = 2;
                switch (this->LA(1))
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    {
                        alt18 = 1;
                    }
                        break;

                }

                switch (alt18)
                {
                    case 1:
                        // Svg.g:
                    {
                        if (((this->LA(1) >= '0') && (this->LA(1) <= '9')))
                        {
                            if (this->LA(1) == '0')
                                number += '0';
                            else if (this->LA(1) == '1')
                                number += '1';
                            else if (this->LA(1) == '2')
                                number += '2';
                            else if (this->LA(1) == '3')
                                number += '3';
                            else if (this->LA(1) == '4')
                                number += '4';
                            else if (this->LA(1) == '5')
                                number += '5';
                            else if (this->LA(1) == '6')
                                number += '6';
                            else if (this->LA(1) == '7')
                                number += '7';
                            else if (this->LA(1) == '8')
                                number += '8';
                            else
                                number += '9';
                            this->consume();
                        }
                        else
                        {
                            new ANTLR_Exception< SvgLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType > (this->get_rec(), "");

                            this->recover();
                            goto ruleEXPONENTEx;
                        }


                    }
                        break;

                    default:

                        if (cnt18 >= 1)
                        {
                            goto loop18;
                        }
                        /* mismatchedSetEx()
                         */
                        new ANTLR_Exception< SvgLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType > (this->get_rec(), "");


                        goto ruleEXPONENTEx;
                }
                cnt18++;
            }
loop18:
            ; /* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
ruleEXPONENTEx:
    ;

}
// $ANTLR end EXPONENT

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
SvgLexer::mTokens()
{
    {
        //  Svg.g:1:8: ( T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | T__29 | T__30 | T__31 | T__32 | T__33 | T__34 | T__35 | T__36 | T__37 | T__38 | T__39 | COMMA_WSP | NUMBER )

        ANTLR_UINT32 alt19;

        alt19 = 28;

        switch (this->LA(1))
        {
            case ' ':
            {
                switch (this->LA(2))
                {
                    case '\t':
                    case '\n':
                    case '\r':
                    case ' ':
                    case ',':
                    {
                        alt19 = 27;
                    }
                        break;

                    default:
                        alt19 = 1;
                }

            }
                break;
            case '0':
            {
                switch (this->LA(2))
                {
                    case '.':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'E':
                    case 'e':
                    {
                        alt19 = 28;
                    }
                        break;

                    default:
                        alt19 = 28;
                }

            }
                break;
            case '1':
            {
                switch (this->LA(2))
                {
                    case '.':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'E':
                    case 'e':
                    {
                        alt19 = 28;
                    }
                        break;

                    default:
                        alt19 = 28;
                }

            }
                break;
            case 'A':
            {
                alt19 = 4;
            }
                break;
            case 'C':
            {
                alt19 = 5;
            }
                break;
            case 'H':
            {
                alt19 = 6;
            }
                break;
            case 'L':
            {
                alt19 = 7;
            }
                break;
            case 'M':
            {
                alt19 = 8;
            }
                break;
            case 'Q':
            {
                alt19 = 9;
            }
                break;
            case 'S':
            {
                alt19 = 10;
            }
                break;
            case 'T':
            {
                alt19 = 11;
            }
                break;
            case 'V':
            {
                alt19 = 12;
            }
                break;
            case 'Z':
            {
                alt19 = 13;
            }
                break;
            case '\n':
            {
                switch (this->LA(2))
                {
                    case '\t':
                    case '\n':
                    case '\r':
                    case ' ':
                    case ',':
                    {
                        alt19 = 27;
                    }
                        break;

                    default:
                        alt19 = 14;
                }

            }
                break;
            case '\r':
            {
                switch (this->LA(2))
                {
                    case '\t':
                    case '\n':
                    case '\r':
                    case ' ':
                    case ',':
                    {
                        alt19 = 27;
                    }
                        break;

                    default:
                        alt19 = 15;
                }

            }
                break;
            case '\t':
            {
                switch (this->LA(2))
                {
                    case '\t':
                    case '\n':
                    case '\r':
                    case ' ':
                    case ',':
                    {
                        alt19 = 27;
                    }
                        break;

                    default:
                        alt19 = 16;
                }

            }
                break;
            case 'a':
            {
                alt19 = 17;
            }
                break;
            case 'c':
            {
                alt19 = 18;
            }
                break;
            case 'h':
            {
                alt19 = 19;
            }
                break;
            case 'l':
            {
                alt19 = 20;
            }
                break;
            case 'm':
            {
                alt19 = 21;
            }
                break;
            case 'q':
            {
                alt19 = 22;
            }
                break;
            case 's':
            {
                alt19 = 23;
            }
                break;
            case 't':
            {
                alt19 = 24;
            }
                break;
            case 'v':
            {
                alt19 = 25;
            }
                break;
            case 'z':
            {
                alt19 = 26;
            }
                break;
            case ',':
            {
                alt19 = 27;
            }
                break;
            case '-':
            case '.':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                alt19 = 28;
            }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SvgLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType > (this->get_rec(), "");
                ex->set_decisionNum(19);
                ex->set_state(0);


                goto ruleTokensEx;

        }

        switch (alt19)
        {
            case 1:
                // Svg.g:1:10: T__14
            {
                /* 1:10: T__14 */
                mT__14();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 2:
                // Svg.g:1:16: T__15
            {
                /* 1:16: T__15 */
                mT__15();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 3:
                // Svg.g:1:22: T__16
            {
                /* 1:22: T__16 */
                mT__16();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 4:
                // Svg.g:1:28: T__17
            {
                /* 1:28: T__17 */
                mT__17();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 5:
                // Svg.g:1:34: T__18
            {
                /* 1:34: T__18 */
                mT__18();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 6:
                // Svg.g:1:40: T__19
            {
                /* 1:40: T__19 */
                mT__19();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 7:
                // Svg.g:1:46: T__20
            {
                /* 1:46: T__20 */
                mT__20();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 8:
                // Svg.g:1:52: T__21
            {
                /* 1:52: T__21 */
                mT__21();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 9:
                // Svg.g:1:58: T__22
            {
                /* 1:58: T__22 */
                mT__22();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 10:
                // Svg.g:1:64: T__23
            {
                /* 1:64: T__23 */
                mT__23();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 11:
                // Svg.g:1:70: T__24
            {
                /* 1:70: T__24 */
                mT__24();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 12:
                // Svg.g:1:76: T__25
            {
                /* 1:76: T__25 */
                mT__25();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 13:
                // Svg.g:1:82: T__26
            {
                /* 1:82: T__26 */
                mT__26();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 14:
                // Svg.g:1:88: T__27
            {
                /* 1:88: T__27 */
                mT__27();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 15:
                // Svg.g:1:94: T__28
            {
                /* 1:94: T__28 */
                mT__28();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 16:
                // Svg.g:1:100: T__29
            {
                /* 1:100: T__29 */
                mT__29();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 17:
                // Svg.g:1:106: T__30
            {
                /* 1:106: T__30 */
                mT__30();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 18:
                // Svg.g:1:112: T__31
            {
                /* 1:112: T__31 */
                mT__31();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 19:
                // Svg.g:1:118: T__32
            {
                /* 1:118: T__32 */
                mT__32();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 20:
                // Svg.g:1:124: T__33
            {
                /* 1:124: T__33 */
                mT__33();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 21:
                // Svg.g:1:130: T__34
            {
                /* 1:130: T__34 */
                mT__34();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 22:
                // Svg.g:1:136: T__35
            {
                /* 1:136: T__35 */
                mT__35();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 23:
                // Svg.g:1:142: T__36
            {
                /* 1:142: T__36 */
                mT__36();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 24:
                // Svg.g:1:148: T__37
            {
                /* 1:148: T__37 */
                mT__37();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 25:
                // Svg.g:1:154: T__38
            {
                /* 1:154: T__38 */
                mT__38();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 26:
                // Svg.g:1:160: T__39
            {
                /* 1:160: T__39 */
                mT__39();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 27:
                // Svg.g:1:166: COMMA_WSP
            {
                /* 1:166: COMMA_WSP */
                mCOMMA_WSP();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;
            case 28:
                // Svg.g:1:176: NUMBER
            {
                /* 1:176: NUMBER */                
                mNUMBER();
                if (this->hasException())
                {
                    goto ruleTokensEx;
                }



            }
                break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx:
    ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */



/* End of code
 * =============================================================================
 */