#include "ros/ros.h"
#include "std_msgs/String.h"
#include <sensor_msgs/Image.h>
#include <cstdio>

namespace LineIn
{

#define SAFE_DELETE( p ) { if( p ) { delete ( p ); ( p ) = NULL; } }
#define SAFE_DELETE_ARRAY( p ) { if( p ) { delete[] ( p ); ( p ) = NULL; } }

struct Pixel
{
	unsigned int r;
	unsigned int g;
	unsigned int b;	
	unsigned int a;

	Pixel(int r, int g, int b, int a = 0) : r(r), g(g), b(b) {}
	~Pixel() {}
	
	friend std::ostream& operator<<(std::ostream& out, const Pixel& img)
	{
		out << "{" << img.r << "," << img.g << "," << img.b << "}";
		return out;
	}
};


struct Image
{
	unsigned int width;
	unsigned int height;
	
	Pixel*** imageMatrix; //pod dva nejde:)

	Image(int width, int height)	: width(width), height(height)
	{
		if(width > 0 && height > 0)
		{
			imageMatrix = new Pixel** [width];
			for(int i = 0; i < width; ++i)
			{
				imageMatrix[i] = new Pixel* [height];
				for(int j = 0; j < height; ++j)			
					imageMatrix[i][j] = new Pixel(0, 0, 0);						
			}
		}
	}
	
	Image(const sensor_msgs::Image::ConstPtr& img)
	{
		if(img->width > 0 && img->height > 0)
		{
			width = img->width;
			height = img->height;

			std::vector<unsigned char> data = img->data;
			unsigned int index = 0;

			imageMatrix = new Pixel** [width];
			for(unsigned int i = 0; i < width; ++i)
			{
				imageMatrix[i] = new Pixel* [height];
				for(unsigned int j = 0; j < height; ++j)			
				{	
					index = i + j;
					imageMatrix[i][j] = new Pixel(data[index], data[index + 1], data[index + 2]);						
				}
			}
		}
	}
	
	~Image()
	{		
		for(unsigned int i = 0; i < width; ++i)
		{	
			Pixel** temp = imageMatrix[i];
			for(unsigned int j = 0; j < height; ++j)			
				 SAFE_DELETE(temp[j]);
			SAFE_DELETE_ARRAY(temp);
		}
		SAFE_DELETE_ARRAY(imageMatrix);
	}

	friend std::ostream& operator<<(std::ostream& out, const Image& img)
	{		
		for(unsigned int i = 0; i < img.width; ++i)
		{			
			for(unsigned int j = 0; j < img.height; ++j)			
			{
				out << *img.imageMatrix[i][j];
			}
			out << "\n";
		}
		out << "\n\n";
		return out;
	}
};

class ImageWorker
{
private:
	ros::NodeHandle m_handler;
	ros::Subscriber m_sub;
	Image* 	    m_currentImage;
	
public:
	ImageWorker();	
	~ImageWorker();
	
	void imageCallback(const sensor_msgs::Image::ConstPtr& msg_ptr);
};


ImageWorker::ImageWorker() :  m_currentImage(NULL)
{
	m_sub = m_handler.subscribe("/camera/rgb/image_color", 1000, &ImageWorker::imageCallback, this);		
}


ImageWorker::~ImageWorker()
{
	SAFE_DELETE(m_currentImage);
}


void ImageWorker::imageCallback(const sensor_msgs::Image::ConstPtr& msg)
{	
	m_currentImage = new Image(msg);
	
	std::cout << *m_currentImage;
	ROS_INFO("IMAGE height [%u] width [%u] %s\n", msg->height, msg->width, msg->encoding.c_str());		

	std::vector<unsigned char> data = msg->data;

	int count = 0;
	if(data.size() > 0)
	{
		for(size_t i = 1; i < 10; ++i)
		{
			printf("%u", data[i]);
			count++;
		}		
	}
	SAFE_DELETE(m_currentImage);
}

}

int main(int argc, char** argv)
{
	ros::init(argc, argv, "line");
	ROS_INFO("Line started");

	//ros::NodeHandle handler;
	//ros::NodeHandle handler2;
	//ros::Subscriber rgbSub = handler.subscribe("/camera/rgb/image_color", 1024, imageCallback);
	//ros::Subscriber depthSub = handler2.subscribe("/camera/depth/image_raw", 1024, depthCallback);
	
	LineIn::ImageWorker worker;

	ros::spin();
	return 0;
}



